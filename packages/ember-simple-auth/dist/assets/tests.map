{"version":3,"sources":["vendor/ember-cli/tests-prefix.js","dummy/tests/acceptance/authentication-test.js","dummy/tests/helpers/create-adaptive-store.js","dummy/tests/helpers/create-cookie-store.js","dummy/tests/helpers/destroy-app.js","dummy/tests/helpers/fake-cookie-service.js","dummy/tests/helpers/module-for-acceptance.js","dummy/tests/helpers/resolver.js","dummy/tests/helpers/start-app.js","dummy/tests/helpers/torii.js","dummy/tests/test-helper.js","dummy/tests/unit/authenticators/base-test.js","dummy/tests/unit/authenticators/devise-test.js","dummy/tests/unit/authenticators/oauth2-implicit-grant-test.js","dummy/tests/unit/authenticators/oauth2-password-grant-test.js","dummy/tests/unit/authenticators/test-test.js","dummy/tests/unit/authenticators/torii-test.js","dummy/tests/unit/configuration-test.js","dummy/tests/unit/initializers/setup-session-restoration-test.js","dummy/tests/unit/initializers/setup-session-service-test.js","dummy/tests/unit/initializers/setup-session-test.js","dummy/tests/unit/internal-session-test.js","dummy/tests/unit/mixins/application-route-mixin-test.js","dummy/tests/unit/mixins/authenticated-route-mixin-test.js","dummy/tests/unit/mixins/data-adapter-mixin-test.js","dummy/tests/unit/mixins/oauth2-implicit-grant-callback-route-mixin-test.js","dummy/tests/unit/mixins/unauthenticated-route-mixin-test.js","dummy/tests/unit/register-version-test.js","dummy/tests/unit/routes/application-test.js","dummy/tests/unit/routes/login-test.js","dummy/tests/unit/routes/protected-test.js","dummy/tests/unit/services/session-test.js","dummy/tests/unit/session-stores/adaptive-test.js","dummy/tests/unit/session-stores/cookie-test.js","dummy/tests/unit/session-stores/ephemeral-test.js","dummy/tests/unit/session-stores/local-storage-test.js","dummy/tests/unit/session-stores/session-storage-test.js","dummy/tests/unit/session-stores/shared/cookie-store-behavior.js","dummy/tests/unit/session-stores/shared/storage-event-handler-behavior.js","dummy/tests/unit/session-stores/shared/store-behavior.js","dummy/tests/unit/utils/location-test.js","dummy/tests/unit/utils/objects-are-equal-test.js","vendor/ember-cli/app-config.js","vendor/ember-cli/tests-suffix.js"],"sourcesContent":["'use strict';\n","define(\"dummy/tests/acceptance/authentication-test\", [\"@ember/test-helpers\", \"ember-test-helpers/has-ember-version\", \"mocha\", \"ember-mocha\", \"chai\", \"pretender\", \"ember-simple-auth/test-support\", \"dummy/config/environment\"], function (_testHelpers, _hasEmberVersion, _mocha, _emberMocha, _chai, _pretender, _testSupport, _environment) {\n  \"use strict\";\n\n  (0, _mocha.describe)('Acceptance: Authentication', function () {\n    (0, _emberMocha.setupApplicationTest)();\n    let server;\n    (0, _mocha.afterEach)(function () {\n      Ember.tryInvoke(server, 'shutdown');\n    });\n    (0, _mocha.describe)('the protected route', function () {\n      if (!(0, _hasEmberVersion.default)(2, 4)) {\n        // guard against running test module on unsupported version (before 2.4)\n        return;\n      }\n\n      (0, _mocha.it)('cannot be visited when the session is not authenticated', async function () {\n        await (0, _testSupport.invalidateSession)();\n        await (0, _testHelpers.visit)('/protected');\n        (0, _chai.expect)((0, _testHelpers.currentURL)()).to.eq('/login');\n      });\n      (0, _mocha.it)('can be visited when the session is authenticated', async function () {\n        server = new _pretender.default(function () {\n          this.get(`${_environment.default.apiHost}/posts`, () => [200, {\n            'Content-Type': 'application/json'\n          }, '{\"data\":[]}']);\n        });\n        await (0, _testSupport.authenticateSession)({\n          userId: 1,\n          otherData: 'some-data'\n        });\n        await (0, _testHelpers.visit)('/protected');\n        let session = (0, _testSupport.currentSession)();\n        (0, _chai.expect)((0, _testHelpers.currentURL)()).to.eq('/protected');\n        (0, _chai.expect)(session.get('data.authenticated.userId')).to.eql(1);\n        (0, _chai.expect)(session.get('data.authenticated.otherData')).to.eql('some-data');\n      });\n    });\n    (0, _mocha.describe)('the protected route in the engine', function () {\n      (0, _mocha.it)('cannot be visited when the session is not authenticated', async function () {\n        await (0, _testSupport.invalidateSession)();\n        await (0, _testHelpers.visit)('/engine');\n        (0, _chai.expect)((0, _testHelpers.currentURL)()).to.eq('/login');\n      });\n      (0, _mocha.it)('can be visited when the session is authenticated', async function () {\n        server = new _pretender.default(function () {\n          this.get(`${_environment.default.apiHost}/posts`, () => [200, {\n            'Content-Type': 'application/json'\n          }, '{\"data\":[]}']);\n        });\n        await (0, _testSupport.authenticateSession)({\n          userId: 1,\n          otherData: 'some-data'\n        });\n        await (0, _testHelpers.visit)('/engine');\n        (0, _chai.expect)((0, _testHelpers.currentURL)()).to.eq('/engine');\n        let session = (0, _testSupport.currentSession)();\n        (0, _chai.expect)(session.get('data.authenticated.userId')).to.eql(1);\n        (0, _chai.expect)(session.get('data.authenticated.otherData')).to.eql('some-data');\n      });\n      (0, _mocha.it)('can invalidate the session', async function () {\n        server = new _pretender.default(function () {\n          this.get(`${_environment.default.apiHost}/posts`, () => [200, {\n            'Content-Type': 'application/json'\n          }, '{\"data\":[]}']);\n        });\n        await (0, _testSupport.authenticateSession)({\n          userId: 1,\n          otherData: 'some-data'\n        });\n        await (0, _testHelpers.visit)('/engine');\n        await (0, _testHelpers.click)('[data-test-logout-button]');\n        let session = (0, _testSupport.currentSession)();\n        (0, _chai.expect)(session.get('isAuthenticated')).to.be.false;\n      });\n    });\n    (0, _mocha.describe)('the login route', function () {\n      if (!(0, _hasEmberVersion.default)(2, 4)) {\n        // guard against running test module on unsupported version (before 2.4)\n        return;\n      }\n\n      (0, _mocha.it)('can be visited when the session is not authenticated', async function () {\n        await (0, _testSupport.invalidateSession)();\n        await (0, _testHelpers.visit)('/login');\n        (0, _chai.expect)((0, _testHelpers.currentURL)()).to.eq('/login');\n      });\n      (0, _mocha.it)('cannot be visited when the session is authenticated', async function () {\n        await (0, _testSupport.authenticateSession)();\n        await (0, _testHelpers.visit)('/login');\n        (0, _chai.expect)((0, _testHelpers.currentURL)()).to.eq('/');\n      });\n    });\n  });\n});","define(\"dummy/tests/helpers/create-adaptive-store\", [\"exports\", \"ember-simple-auth/session-stores/adaptive\", \"dummy/tests/helpers/create-cookie-store\"], function (_exports, _adaptive, _createCookieStore) {\n  \"use strict\";\n\n  Object.defineProperty(_exports, \"__esModule\", {\n    value: true\n  });\n  _exports.default = createAdaptiveStore;\n  const assign = Ember.assign || Ember.merge;\n\n  function createAdaptiveStore(cookiesService, options = {}, props = {}) {\n    let cookieStore = (0, _createCookieStore.default)(cookiesService, assign({}, options, {\n      _isFastboot: false\n    }));\n\n    props._createStore = function () {\n      cookieStore.on('sessionDataUpdated', data => {\n        this.trigger('sessionDataUpdated', data);\n      });\n      return cookieStore;\n    };\n\n    return _adaptive.default.extend(props).create(options);\n  }\n});","define(\"dummy/tests/helpers/create-cookie-store\", [\"exports\", \"ember-simple-auth/session-stores/cookie\"], function (_exports, _cookie) {\n  \"use strict\";\n\n  Object.defineProperty(_exports, \"__esModule\", {\n    value: true\n  });\n  _exports.default = createCookieStore;\n\n  function createCookieStore(cookiesService, options = {}) {\n    options._cookies = cookiesService;\n    options._fastboot = {\n      isFastBoot: false\n    };\n    return _cookie.default.create(options);\n  }\n});","define(\"dummy/tests/helpers/destroy-app\", [\"exports\"], function (_exports) {\n  \"use strict\";\n\n  Object.defineProperty(_exports, \"__esModule\", {\n    value: true\n  });\n  _exports.default = destroyApp;\n\n  function destroyApp(application) {\n    Ember.run(application, 'destroy');\n  }\n});","define(\"dummy/tests/helpers/fake-cookie-service\", [\"exports\"], function (_exports) {\n  \"use strict\";\n\n  Object.defineProperty(_exports, \"__esModule\", {\n    value: true\n  });\n  _exports.default = void 0;\n\n  var _default = Ember.Object.extend({\n    init() {\n      this._super(...arguments);\n\n      this._content = {};\n    },\n\n    read(name) {\n      const value = name ? this._content[name] : this._content;\n\n      if (Ember.isNone(value)) {\n        return value;\n      } else {\n        return decodeURIComponent(value);\n      }\n    },\n\n    write(name, value) {\n      if (Ember.isNone(value)) {\n        delete this._content[name];\n      } else {\n        this._content[name] = encodeURIComponent(value);\n      }\n    },\n\n    clear(name) {\n      let expires = new Date(0);\n      this.write(name, null, {\n        expires\n      });\n    }\n\n  });\n\n  _exports.default = _default;\n});","define(\"dummy/tests/helpers/module-for-acceptance\", [\"exports\", \"qunit\", \"dummy/tests/helpers/start-app\", \"dummy/tests/helpers/destroy-app\"], function (_exports, _qunit, _startApp, _destroyApp) {\n  \"use strict\";\n\n  Object.defineProperty(_exports, \"__esModule\", {\n    value: true\n  });\n  _exports.default = _default;\n\n  function _default(name, options = {}) {\n    (0, _qunit.module)(name, {\n      beforeEach() {\n        this.application = (0, _startApp.default)();\n\n        if (options.beforeEach) {\n          return options.beforeEach.apply(this, arguments);\n        }\n      },\n\n      afterEach() {\n        let afterEach = options.afterEach && options.afterEach.apply(this, arguments);\n        return Ember.RSVP.resolve(afterEach).then(() => (0, _destroyApp.default)(this.application));\n      }\n\n    });\n  }\n});","define(\"dummy/tests/helpers/resolver\", [\"exports\", \"dummy/resolver\", \"dummy/config/environment\"], function (_exports, _resolver, _environment) {\n  \"use strict\";\n\n  Object.defineProperty(_exports, \"__esModule\", {\n    value: true\n  });\n  _exports.default = void 0;\n\n  const resolver = _resolver.default.create();\n\n  resolver.namespace = {\n    modulePrefix: _environment.default.modulePrefix,\n    podModulePrefix: _environment.default.podModulePrefix\n  };\n  var _default = resolver;\n  _exports.default = _default;\n});","define(\"dummy/tests/helpers/start-app\", [\"exports\", \"dummy/app\", \"dummy/config/environment\"], function (_exports, _app, _environment) {\n  \"use strict\";\n\n  Object.defineProperty(_exports, \"__esModule\", {\n    value: true\n  });\n  _exports.default = startApp;\n\n  function startApp(attrs) {\n    let attributes = Ember.merge({}, _environment.default.APP);\n    attributes.autoboot = true;\n    attributes = Ember.merge(attributes, attrs); // use defaults, but you can override;\n\n    return Ember.run(() => {\n      let application = _app.default.create(attributes);\n\n      application.setupForTesting();\n      application.injectTestHelpers();\n      return application;\n    });\n  }\n});","define(\"dummy/tests/helpers/torii\", [\"exports\", \"dummy/config/environment\"], function (_exports, _environment) {\n  \"use strict\";\n\n  Object.defineProperty(_exports, \"__esModule\", {\n    value: true\n  });\n  _exports.stubValidSession = stubValidSession;\n  const {\n    torii: {\n      sessionServiceName\n    }\n  } = _environment.default;\n\n  function stubValidSession(application, sessionData) {\n    let session = application.__container__.lookup(`service:${sessionServiceName}`);\n\n    let sm = session.get('stateMachine');\n    Ember.run(() => {\n      sm.send('startOpen');\n      sm.send('finishOpen', sessionData);\n    });\n  }\n});","define(\"dummy/tests/test-helper\", [\"@ember/test-helpers\", \"dummy/app\", \"dummy/config/environment\"], function (_testHelpers, _app, _environment) {\n  \"use strict\";\n\n  (0, _testHelpers.setApplication)(_app.default.create(_environment.default.APP));\n});","define(\"dummy/tests/unit/authenticators/base-test\", [\"mocha\", \"chai\", \"ember-simple-auth/authenticators/base\"], function (_mocha, _chai, _base) {\n  \"use strict\";\n\n  (0, _mocha.describe)('BaseAuthenticator', () => {\n    let authenticator;\n    (0, _mocha.beforeEach)(function () {\n      authenticator = _base.default.create();\n    });\n    (0, _mocha.describe)('#restore', function () {\n      (0, _mocha.it)('returns a rejecting promise', async function () {\n        try {\n          await authenticator.restore();\n          (0, _chai.expect)(false).to.be.true;\n        } catch (_error) {\n          (0, _chai.expect)(true).to.be.true;\n        }\n      });\n    });\n    (0, _mocha.describe)('#authenticate', function () {\n      (0, _mocha.it)('returns a rejecting promise', async function () {\n        try {\n          await authenticator.authenticate();\n          (0, _chai.expect)(false).to.be.true;\n        } catch (_error) {\n          (0, _chai.expect)(true).to.be.true;\n        }\n      });\n    });\n    (0, _mocha.describe)('#invalidate', function () {\n      (0, _mocha.it)('returns a resolving promise', async function () {\n        try {\n          await authenticator.invalidate();\n          (0, _chai.expect)(true).to.be.true;\n        } catch (_error) {\n          (0, _chai.expect)(false).to.be.true;\n        }\n      });\n    });\n  });\n});","define(\"dummy/tests/unit/authenticators/devise-test\", [\"mocha\", \"chai\", \"pretender\", \"ember-simple-auth/authenticators/devise\"], function (_mocha, _chai, _pretender, _devise) {\n  \"use strict\";\n\n  (0, _mocha.describe)('DeviseAuthenticator', () => {\n    let server;\n    let authenticator;\n    (0, _mocha.beforeEach)(function () {\n      server = new _pretender.default();\n      authenticator = _devise.default.create();\n    });\n    (0, _mocha.afterEach)(function () {\n      Ember.tryInvoke(server, 'shutdown');\n    });\n    (0, _mocha.describe)('#restore', function () {\n      (0, _mocha.describe)('when the data contains a token and email', function () {\n        (0, _mocha.it)('resolves with the correct data', async function () {\n          let content = await authenticator.restore({\n            token: 'secret token!',\n            email: 'user@email.com'\n          });\n          (0, _chai.expect)(content).to.eql({\n            token: 'secret token!',\n            email: 'user@email.com'\n          });\n        });\n      });\n      (0, _mocha.describe)('when the data contains a custom token and email attribute', function () {\n        (0, _mocha.beforeEach)(function () {\n          authenticator = _devise.default.extend({\n            tokenAttributeName: 'employee.token',\n            identificationAttributeName: 'employee.email'\n          }).create();\n        });\n        (0, _mocha.it)('resolves with the correct data', async function () {\n          let content = await authenticator.restore({\n            employee: {\n              token: 'secret token!',\n              email: 'user@email.com'\n            }\n          });\n          (0, _chai.expect)(content).to.eql({\n            employee: {\n              token: 'secret token!',\n              email: 'user@email.com'\n            }\n          });\n        });\n      });\n    });\n    (0, _mocha.describe)('#authenticate', function () {\n      (0, _mocha.beforeEach)(function () {\n        server.post('/users/sign_in', () => [201, {\n          'Content-Type': 'application/json'\n        }, '{ \"token\": \"secret token!\", \"email\": \"email@address.com\" }']);\n      });\n      (0, _mocha.it)('sends an AJAX request to the sign in endpoint', async function () {\n        await authenticator.authenticate('identification', 'password');\n        let [request] = server.handledRequests;\n        (0, _chai.expect)(request.url).to.eql('/users/sign_in');\n        (0, _chai.expect)(request.method).to.eql('POST');\n        (0, _chai.expect)(JSON.parse(request.requestBody)).to.eql({\n          user: {\n            email: 'identification',\n            password: 'password'\n          }\n        });\n        (0, _chai.expect)(request.requestHeaders['content-type']).to.eql('application/json');\n        (0, _chai.expect)(request.requestHeaders.accept).to.eql('application/json');\n      });\n      (0, _mocha.describe)('when the authentication request is successful', function () {\n        (0, _mocha.beforeEach)(function () {\n          server.post('/users/sign_in', () => [201, {\n            'Content-Type': 'application/json'\n          }, '{ \"token\": \"secret token!\", \"email\": \"email@address.com\" }']);\n        });\n        (0, _mocha.it)('resolves with the correct data', async function () {\n          let data = await authenticator.authenticate('email@address.com', 'password');\n          (0, _chai.expect)(data).to.eql({\n            token: 'secret token!',\n            email: 'email@address.com'\n          });\n        });\n        (0, _mocha.describe)('when the server returns incomplete data', function () {\n          (0, _mocha.it)('fails when token is missing', async function () {\n            server.post('/users/sign_in', () => [201, {\n              'Content-Type': 'application/json'\n            }, '{ \"email\": \"email@address.com\" }']);\n\n            try {\n              await authenticator.authenticate('email@address.com', 'password');\n              (0, _chai.expect)(false).to.be.true;\n            } catch (error) {\n              (0, _chai.expect)(error).to.eql('Check that server response includes token and email');\n            }\n          });\n          (0, _mocha.it)('fails when identification is missing', async function () {\n            server.post('/users/sign_in', () => [201, {\n              'Content-Type': 'application/json'\n            }, '{ \"token\": \"secret token!\" }']);\n\n            try {\n              await authenticator.authenticate('email@address.com', 'password');\n              (0, _chai.expect)(false).to.be.true;\n            } catch (error) {\n              (0, _chai.expect)(error).to.eql('Check that server response includes token and email');\n            }\n          });\n        });\n      });\n      (0, _mocha.describe)('when the authentication request fails', function () {\n        (0, _mocha.beforeEach)(function () {\n          server.post('/users/sign_in', () => [400, {\n            'Content-Type': 'application/json',\n            'X-Custom-Context': 'foobar'\n          }, '{ \"error\": \"invalid_grant\" }']);\n        });\n        (0, _mocha.it)('rejects with the response', async function () {\n          try {\n            await authenticator.authenticate('username', 'password');\n            (0, _chai.expect)(false).to.be.true;\n          } catch (response) {\n            (0, _chai.expect)(response.ok).to.be.false;\n          }\n        });\n      });\n      (0, _mocha.it)('can customize the ajax request', async function () {\n        server.put('/login', () => [201, {\n          'Content-Type': 'application/json'\n        }, '{ \"token\": \"secret token!\", \"email\": \"email@address.com\" }']);\n        authenticator = _devise.default.extend({\n          makeRequest(config) {\n            return this._super(config, {\n              method: 'PUT',\n              url: '/login'\n            });\n          }\n\n        }).create();\n        await authenticator.authenticate('identification', 'password');\n        let [request] = server.handledRequests;\n        (0, _chai.expect)(request.url).to.eql('/login');\n        (0, _chai.expect)(request.method).to.eql('PUT');\n      });\n      (0, _mocha.it)('can handle a resp with the namespace of the resource name', async function () {\n        server.post('/users/sign_in', () => [201, {\n          'Content-Type': 'application/json'\n        }, '{ \"user\": { \"token\": \"secret token!\", \"email\": \"email@address.com\" } }']);\n        let data = await authenticator.authenticate('email@address.com', 'password');\n        (0, _chai.expect)(true).to.be.true;\n        (0, _chai.expect)(data).to.eql({\n          token: 'secret token!',\n          email: 'email@address.com'\n        });\n      });\n    });\n    (0, _mocha.describe)('#invalidate', function () {\n      (0, _mocha.it)('returns a resolving promise', async function () {\n        try {\n          await authenticator.invalidate();\n          (0, _chai.expect)(true).to.be.true;\n        } catch (_error) {\n          (0, _chai.expect)(false).to.be.true;\n        }\n      });\n    });\n  });\n});","define(\"dummy/tests/unit/authenticators/oauth2-implicit-grant-test\", [\"ember-mocha\", \"mocha\", \"chai\", \"ember-simple-auth/authenticators/oauth2-implicit-grant\"], function (_emberMocha, _mocha, _chai, _oauth2ImplicitGrant) {\n  \"use strict\";\n\n  (0, _mocha.describe)('OAuth2ImplicitGrantAuthenticator', () => {\n    let authenticator;\n    let data = {\n      'access_token': 'secret-token'\n    };\n    (0, _mocha.beforeEach)(function () {\n      authenticator = _oauth2ImplicitGrant.default.create();\n    });\n    (0, _mocha.describe)('#restore', function () {\n      (0, _mocha.describe)('when the data contains an access_token', function () {\n        (0, _emberMocha.it)('resolves with the correct data', async function () {\n          let _data = await authenticator.restore(data);\n\n          (0, _chai.expect)(_data).to.eql(data);\n        });\n        (0, _mocha.describe)('when the data does not contain an access_token', function () {\n          (0, _emberMocha.it)('returns a rejecting promise', async function () {\n            try {\n              await authenticator.restore();\n              (0, _chai.expect)(false).to.be.true;\n            } catch (error) {\n              (0, _chai.expect)(error).to.eql('Could not restore session - \"access_token\" missing.');\n            }\n          });\n        });\n      });\n    });\n    (0, _mocha.describe)('#authenticate', function () {\n      (0, _mocha.describe)('when the data contains an access_token', function () {\n        (0, _emberMocha.it)('resolves with the correct data', async function () {\n          let _data = await authenticator.authenticate(data);\n\n          (0, _chai.expect)(_data).to.eql(data);\n        });\n      });\n      (0, _mocha.describe)('when the data does not contain an access_token', function () {\n        (0, _emberMocha.it)('rejects with an error', async function () {\n          try {\n            await authenticator.authenticate({\n              foo: 'bar'\n            });\n            (0, _chai.expect)(false).to.be.true;\n          } catch (error) {\n            (0, _chai.expect)(error).to.eql('Invalid auth params - \"access_token\" missing.');\n          }\n        });\n      });\n      (0, _mocha.describe)('when the data contains an error', function () {\n        (0, _emberMocha.it)('rejects with that error', async function () {\n          try {\n            await authenticator.authenticate({\n              error: 'access_denied'\n            });\n            (0, _chai.expect)(false).to.be.true;\n          } catch (error) {\n            (0, _chai.expect)(error).to.eql('access_denied');\n          }\n        });\n      });\n    });\n    (0, _mocha.describe)('#invalidate', function () {\n      (0, _emberMocha.it)('returns a resolving promise', async function () {\n        try {\n          await authenticator.invalidate();\n          (0, _chai.expect)(true).to.be.true;\n        } catch (_error) {\n          (0, _chai.expect)(false).to.be.true;\n        }\n      });\n    });\n  });\n});","define(\"dummy/tests/unit/authenticators/oauth2-password-grant-test\", [\"mocha\", \"ember-mocha\", \"chai\", \"pretender\", \"ember-simple-auth/authenticators/oauth2-password-grant\"], function (_mocha, _emberMocha, _chai, _pretender, _oauth2PasswordGrant) {\n  \"use strict\";\n\n  (0, _mocha.describe)('OAuth2PasswordGrantAuthenticator', () => {\n    (0, _emberMocha.setupTest)();\n    let authenticator;\n    let server;\n\n    let parsePostData = query => {\n      let result = {};\n      query.split('&').forEach(part => {\n        let item = part.split('=');\n        result[item[0]] = decodeURIComponent(item[1]);\n      });\n      return result;\n    };\n\n    (0, _mocha.beforeEach)(function () {\n      authenticator = _oauth2PasswordGrant.default.create();\n      Ember.setOwner(authenticator, this.owner);\n      server = new _pretender.default();\n    });\n    (0, _mocha.afterEach)(function () {\n      Ember.tryInvoke(server, 'shutdown');\n    });\n    (0, _mocha.describe)('#restore', function () {\n      (0, _mocha.describe)('when the data includes expiration data', function () {\n        (0, _mocha.it)('resolves with the correct data', async function () {\n          let data = await authenticator.restore({\n            'access_token': 'secret token!',\n            'expires_in': 12345,\n            'refresh_token': 'refresh token!'\n          });\n          (0, _chai.expect)(data).to.eql({\n            'access_token': 'secret token!',\n            'expires_in': 12345,\n            'refresh_token': 'refresh token!'\n          });\n        });\n        (0, _mocha.describe)('when the data includes an expiration time in the past', function () {\n          (0, _mocha.describe)('when automatic token refreshing is enabled', function () {\n            (0, _mocha.describe)('when the refresh request is successful', function () {\n              (0, _mocha.beforeEach)(function () {\n                server.post('/token', () => [200, {\n                  'Content-Type': 'application/json'\n                }, '{ \"access_token\": \"secret token 2!\", \"expires_in\": 67890, \"refresh_token\": \"refresh token 2!\" }']);\n              });\n              (0, _mocha.it)('resolves with the correct data', async function () {\n                let data = await authenticator.restore({\n                  'access_token': 'secret token!',\n                  'expires_at': 1\n                });\n                (0, _chai.expect)(data['expires_at']).to.be.greaterThan(new Date().getTime());\n                delete data['expires_at'];\n                (0, _chai.expect)(data).to.eql({\n                  'access_token': 'secret token 2!',\n                  'expires_in': 67890,\n                  'refresh_token': 'refresh token 2!'\n                });\n              });\n            });\n            (0, _mocha.describe)('when the access token is not refreshed successfully', function () {\n              (0, _mocha.it)('returns a rejecting promise', async function () {\n                try {\n                  await authenticator.restore({\n                    'access_token': 'secret token!',\n                    'expires_at': 1\n                  });\n                  (0, _chai.expect)(false).to.be.true;\n                } catch (_error) {\n                  (0, _chai.expect)(true).to.be.true;\n                }\n              });\n            });\n          });\n          (0, _mocha.describe)('when automatic token refreshing is disabled', function () {\n            (0, _mocha.beforeEach)(function () {\n              authenticator.set('refreshAccessTokens', false);\n            });\n            (0, _mocha.it)('returns a rejecting promise', async function () {\n              try {\n                await authenticator.restore({\n                  'access_token': 'secret token!',\n                  'expires_at': 1\n                });\n                (0, _chai.expect)(false).to.be.true;\n              } catch (_error) {\n                (0, _chai.expect)(true).to.be.true;\n              }\n            });\n          });\n        });\n      });\n      (0, _mocha.describe)('when the data does not include expiration data', function () {\n        (0, _mocha.describe)('when the data contains an access_token', function () {\n          (0, _mocha.it)('resolves with the correct data', async function () {\n            let data = await authenticator.restore({\n              'access_token': 'secret token!'\n            });\n            (0, _chai.expect)(data).to.eql({\n              'access_token': 'secret token!'\n            });\n          });\n        });\n        (0, _mocha.describe)('when the data does not contain an access_token', function () {\n          (0, _mocha.it)('returns a rejecting promise', async function () {\n            try {\n              await authenticator.restore();\n              (0, _chai.expect)(false).to.be.true;\n            } catch (_error) {\n              (0, _chai.expect)(true).to.be.true;\n            }\n          });\n        });\n      });\n    });\n    (0, _mocha.describe)('#authenticate', function () {\n      (0, _mocha.it)('sends an AJAX request to the token endpoint', async function () {\n        server.post('/token', request => {\n          let body = parsePostData(request.requestBody);\n          (0, _chai.expect)(body).to.eql({\n            'grant_type': 'password',\n            'username': 'username',\n            'password': 'password'\n          });\n          return [200, {\n            'Content-Type': 'application/json'\n          }, '{ \"access_token\": \"secret token!\" }'];\n        });\n        await authenticator.authenticate('username', 'password');\n      });\n      (0, _mocha.it)('sends an AJAX request to the token endpoint with client_id as parameter in the body', async function () {\n        server.post('/token', request => {\n          let body = parsePostData(request.requestBody);\n          (0, _chai.expect)(body).to.eql({\n            'client_id': 'test-client',\n            'grant_type': 'password',\n            'username': 'username',\n            'password': 'password'\n          });\n          return [200, {\n            'Content-Type': 'application/json'\n          }, '{ \"access_token\": \"secret token!\" }'];\n        });\n        authenticator.set('clientId', 'test-client');\n        await authenticator.authenticate('username', 'password');\n      });\n      (0, _mocha.it)('sends an AJAX request to the token endpoint with customized headers', async function () {\n        server.post('/token', request => {\n          (0, _chai.expect)(request.requestHeaders['x-custom-context']).to.eql('foobar');\n          return [200, {\n            'Content-Type': 'application/json'\n          }, '{ \"access_token\": \"secret token!\" }'];\n        });\n        await authenticator.authenticate('username', 'password', [], {\n          'X-Custom-Context': 'foobar'\n        });\n      });\n      (0, _mocha.it)('sends a single OAuth scope to the token endpoint', async function () {\n        server.post('/token', request => {\n          let {\n            requestBody\n          } = request;\n          let {\n            scope\n          } = parsePostData(requestBody);\n          (0, _chai.expect)(scope).to.eql('public');\n          return [200, {\n            'Content-Type': 'application/json'\n          }, '{ \"access_token\": \"secret token!\" }'];\n        });\n        await authenticator.authenticate('username', 'password', 'public');\n      });\n      (0, _mocha.it)('sends multiple OAuth scopes to the token endpoint', async function () {\n        server.post('/token', request => {\n          let {\n            requestBody\n          } = request;\n          let {\n            scope\n          } = parsePostData(requestBody);\n          (0, _chai.expect)(scope).to.eql('public private');\n          return [200, {\n            'Content-Type': 'application/json'\n          }, '{ \"access_token\": \"secret token!\" }'];\n        });\n        await authenticator.authenticate('username', 'password', ['public', 'private']);\n      });\n      (0, _mocha.describe)('when the authentication request is successful', function () {\n        (0, _mocha.beforeEach)(function () {\n          server.post('/token', () => [200, {\n            'Content-Type': 'application/json'\n          }, '{ \"access_token\": \"secret token!\" }']);\n        });\n        (0, _mocha.it)('resolves with the correct data', async function () {\n          authenticator.set('refreshAccessTokens', false);\n          let data = await authenticator.authenticate('username', 'password');\n          (0, _chai.expect)(data).to.eql({\n            'access_token': 'secret token!'\n          });\n        });\n        (0, _mocha.describe)('when the server response includes expiration data', function () {\n          (0, _mocha.beforeEach)(function () {\n            server.post('/token', () => [200, {\n              'Content-Type': 'application/json'\n            }, '{ \"access_token\": \"secret token!\", \"expires_in\": 12345, \"refresh_token\": \"refresh token!\" }']);\n          });\n          (0, _mocha.it)('resolves with the correct data', async function () {\n            let data = await authenticator.authenticate('username', 'password');\n            (0, _chai.expect)(data['expires_at']).to.be.greaterThan(new Date().getTime());\n            delete data['expires_at'];\n            (0, _chai.expect)(data).to.eql({\n              'access_token': 'secret token!',\n              'expires_in': 12345,\n              'refresh_token': 'refresh token!'\n            });\n          });\n        });\n        (0, _mocha.describe)('when the server response is missing access_token', function () {\n          (0, _mocha.it)('fails with a string describing the issue', async function () {\n            server.post('/token', () => [200, {\n              'Content-Type': 'application/json'\n            }, '{}']);\n\n            try {\n              await authenticator.authenticate('username', 'password');\n              (0, _chai.expect)(false).to.be.true;\n            } catch (error) {\n              (0, _chai.expect)(error).to.eql('access_token is missing in server response');\n            }\n          });\n        });\n        (0, _mocha.describe)('but the response is not valid JSON', function () {\n          (0, _mocha.it)('fails with the string of the response', async function () {\n            server.post('/token', () => [200, {\n              'Content-Type': 'text/plain'\n            }, 'Something went wrong']);\n\n            try {\n              await authenticator.authenticate('username', 'password');\n              (0, _chai.expect)(false).to.be.true;\n            } catch (error) {\n              (0, _chai.expect)(error.responseText).to.eql('Something went wrong');\n            }\n          });\n        });\n      });\n      (0, _mocha.describe)('when the authentication request fails', function () {\n        (0, _mocha.beforeEach)(function () {\n          server.post('/token', () => [400, {\n            'Content-Type': 'application/json',\n            'X-Custom-Context': 'foobar'\n          }, '{ \"error\": \"invalid_grant\" }']);\n        });\n        (0, _mocha.it)('rejects with response object containing responseJSON', async function () {\n          try {\n            await authenticator.authenticate('username', 'password');\n            (0, _chai.expect)(false).to.be.true;\n          } catch (error) {\n            (0, _chai.expect)(error.responseJSON).to.eql({\n              error: 'invalid_grant'\n            });\n          }\n        });\n        (0, _mocha.it)('provides access to custom headers', async function () {\n          try {\n            await authenticator.authenticate('username', 'password');\n            (0, _chai.expect)(false).to.be.true;\n          } catch (error) {\n            (0, _chai.expect)(error.headers.get('x-custom-context')).to.eql('foobar');\n          }\n        });\n      });\n      (0, _mocha.describe)('when the authentication request fails without a valid response', function () {\n        (0, _mocha.beforeEach)(function () {\n          server.post('/token', () => [500, {\n            'Content-Type': 'text/plain',\n            'X-Custom-Context': 'foobar'\n          }, 'The server has failed completely.']);\n        });\n        (0, _mocha.it)('rejects with response object containing responseText', async function () {\n          try {\n            await authenticator.authenticate('username', 'password');\n            (0, _chai.expect)(false).to.be.true;\n          } catch (error) {\n            (0, _chai.expect)(error.responseJSON).to.not.exist;\n            (0, _chai.expect)(error.responseText).to.eql('The server has failed completely.');\n          }\n        });\n        (0, _mocha.it)('provides access to custom headers', async function () {\n          try {\n            await authenticator.authenticate('username', 'password');\n            (0, _chai.expect)(false).to.be.true;\n          } catch (error) {\n            (0, _chai.expect)(error.headers.get('x-custom-context')).to.eql('foobar');\n          }\n        });\n      });\n    });\n    (0, _mocha.describe)('#invalidate', function () {\n      function itSuccessfullyInvalidatesTheSession() {\n        (0, _mocha.it)('returns a resolving promise', async function () {\n          try {\n            await authenticator.invalidate({\n              'access_token': 'access token!'\n            });\n            (0, _chai.expect)(true).to.be.true;\n          } catch (_error) {\n            (0, _chai.expect)(false).to.be.true;\n          }\n        });\n      }\n\n      (0, _mocha.describe)('when token revokation is enabled', function () {\n        (0, _mocha.beforeEach)(function () {\n          authenticator.serverTokenRevocationEndpoint = '/revoke';\n        });\n        (0, _mocha.it)('sends an AJAX request to the revokation endpoint', async function () {\n          server.post('/revoke', request => {\n            let {\n              requestBody\n            } = request;\n            let body = parsePostData(requestBody);\n            (0, _chai.expect)(body).to.eql({\n              'token_type_hint': 'access_token',\n              'token': 'access token!'\n            });\n          });\n          await authenticator.invalidate({\n            'access_token': 'access token!'\n          });\n        });\n        (0, _mocha.describe)('when the revokation request is successful', function () {\n          (0, _mocha.beforeEach)(function () {\n            server.post('/revoke', () => [200, {}, '']);\n          });\n          itSuccessfullyInvalidatesTheSession();\n        });\n        (0, _mocha.describe)('when the revokation request fails', function () {\n          (0, _mocha.beforeEach)(function () {\n            server.post('/token', () => [400, {\n              'Content-Type': 'application/json'\n            }, '{ \"error\": \"unsupported_grant_type\" }']);\n          });\n          itSuccessfullyInvalidatesTheSession();\n        });\n        (0, _mocha.describe)('when a refresh token is set', function () {\n          (0, _mocha.it)('sends an AJAX request to invalidate the refresh token', async function () {\n            server.post('/revoke', request => {\n              let {\n                requestBody\n              } = request;\n              let body = parsePostData(requestBody);\n              (0, _chai.expect)(body).to.eql({\n                'token_type_hint': 'refresh_token',\n                'token': 'refresh token!'\n              });\n            });\n            await authenticator.invalidate({\n              'access_token': 'access token!',\n              'refresh_token': 'refresh token!'\n            });\n          });\n        });\n      });\n      (0, _mocha.describe)('when token revokation is not enabled', function () {\n        itSuccessfullyInvalidatesTheSession();\n      });\n    });\n    (0, _mocha.describe)('#tokenRefreshOffset', function () {\n      (0, _mocha.it)('returns a number between 5000 and 10000', function () {\n        (0, _chai.expect)(authenticator.get('tokenRefreshOffset')).to.be.at.least(5000);\n        (0, _chai.expect)(authenticator.get('tokenRefreshOffset')).to.be.below(10000);\n      });\n      (0, _mocha.it)('can be overridden in a subclass', function () {\n        let authenticator = _oauth2PasswordGrant.default.extend({\n          tokenRefreshOffset: Ember.computed(function () {\n            return 42;\n          })\n        }).create();\n\n        (0, _chai.expect)(authenticator.get('tokenRefreshOffset')).to.equal(42);\n      });\n    }); // testing private API here ;(\n\n    (0, _mocha.describe)('#_refreshAccessToken', function () {\n      (0, _mocha.it)('sends an AJAX request to the token endpoint', async function () {\n        server.post('/token', request => {\n          let {\n            requestBody\n          } = request;\n          let body = parsePostData(requestBody);\n          (0, _chai.expect)(body).to.eql({\n            'grant_type': 'refresh_token',\n            'refresh_token': 'refresh token!'\n          });\n        });\n        await authenticator._refreshAccessToken(12345, 'refresh token!');\n      });\n      (0, _mocha.describe)('when the refresh request is successful', function () {\n        (0, _mocha.beforeEach)(function () {\n          server.post('/token', () => [200, {\n            'Content-Type': 'application/json'\n          }, '{ \"access_token\": \"secret token 2!\" }']);\n        });\n        (0, _mocha.it)('triggers the \"sessionDataUpdated\" event', function (done) {\n          authenticator.one('sessionDataUpdated', data => {\n            (0, _chai.expect)(data['expires_at']).to.be.greaterThan(new Date().getTime());\n            delete data['expires_at'];\n            (0, _chai.expect)(data).to.eql({\n              'access_token': 'secret token 2!',\n              'expires_in': 12345,\n              'refresh_token': 'refresh token!'\n            });\n            done();\n          });\n\n          authenticator._refreshAccessToken(12345, 'refresh token!');\n        });\n        (0, _mocha.describe)('when the server response includes updated expiration data', function () {\n          (0, _mocha.beforeEach)(function () {\n            server.post('/token', () => [200, {\n              'Content-Type': 'application/json'\n            }, '{ \"access_token\": \"secret token 2!\", \"expires_in\": 67890, \"refresh_token\": \"refresh token 2!\" }']);\n          });\n          (0, _mocha.it)('triggers the \"sessionDataUpdated\" event with the correct data', function (done) {\n            authenticator.one('sessionDataUpdated', data => {\n              (0, _chai.expect)(data['expires_at']).to.be.greaterThan(new Date().getTime());\n              delete data['expires_at'];\n              (0, _chai.expect)(data).to.eql({\n                'access_token': 'secret token 2!',\n                'expires_in': 67890,\n                'refresh_token': 'refresh token 2!'\n              });\n              done();\n            });\n\n            authenticator._refreshAccessToken(12345, 'refresh token!');\n          });\n        });\n      });\n    });\n  });\n});","define(\"dummy/tests/unit/authenticators/test-test\", [\"mocha\", \"chai\", \"ember-simple-auth/authenticators/test\"], function (_mocha, _chai, _test) {\n  \"use strict\";\n\n  (0, _mocha.describe)('TestAuthenticator', () => {\n    let authenticator;\n    (0, _mocha.beforeEach)(function () {\n      authenticator = _test.default.create();\n    });\n    (0, _mocha.describe)('#restore', function () {\n      (0, _mocha.it)('returns a resolving promise', async function () {\n        try {\n          await authenticator.restore();\n          (0, _chai.expect)(true).to.be.true;\n        } catch (_error) {\n          (0, _chai.expect)(false).to.be.true;\n        }\n      });\n      (0, _mocha.it)('resolves with session data', async function () {\n        let data = await authenticator.restore({\n          userId: 1,\n          otherData: 'some-data'\n        });\n        (0, _chai.expect)(data).to.eql({\n          userId: 1,\n          otherData: 'some-data'\n        });\n      });\n    });\n    (0, _mocha.describe)('#authenticate', function () {\n      (0, _mocha.it)('returns a resolving promise', async function () {\n        try {\n          await authenticator.authenticate();\n          (0, _chai.expect)(true).to.be.true;\n        } catch (_error) {\n          (0, _chai.expect)(false).to.be.true;\n        }\n      });\n      (0, _mocha.it)('resolves with session data', async function () {\n        let data = await authenticator.authenticate({\n          userId: 1,\n          otherData: 'some-data'\n        });\n        (0, _chai.expect)(data).to.eql({\n          userId: 1,\n          otherData: 'some-data'\n        });\n      });\n    });\n    (0, _mocha.describe)('#invalidate', function () {\n      (0, _mocha.it)('returns a resolving promise', async function () {\n        try {\n          await authenticator.invalidate();\n          (0, _chai.expect)(true).to.be.true;\n        } catch (_error) {\n          (0, _chai.expect)(false).to.be.true;\n        }\n      });\n    });\n  });\n});","define(\"dummy/tests/unit/authenticators/torii-test\", [\"mocha\", \"chai\", \"sinon\", \"ember-simple-auth/authenticators/torii\"], function (_mocha, _chai, _sinon, _torii) {\n  \"use strict\";\n\n  (0, _mocha.describe)('ToriiAuthenticator', () => {\n    let sinon;\n    let authenticator;\n    let torii;\n    (0, _mocha.beforeEach)(function () {\n      sinon = _sinon.default.createSandbox();\n      torii = {\n        fetch() {},\n\n        open() {},\n\n        close() {}\n\n      };\n      authenticator = _torii.default.create({\n        torii\n      });\n    });\n    afterEach(function () {\n      sinon.restore();\n    });\n    (0, _mocha.describe)('#restore', function () {\n      function itDoesNotRestore(data) {\n        (0, _mocha.it)('returns a rejecting promise', async function () {\n          try {\n            await authenticator.restore(data);\n            (0, _chai.expect)(false).to.be.true;\n          } catch (_error) {\n            (0, _chai.expect)(true).to.be.true;\n          }\n        });\n      }\n\n      (0, _mocha.it)('throws if torii is not installed', async function () {\n        authenticator.set('torii', null);\n\n        try {\n          await authenticator.restore();\n          (0, _chai.expect)(false).to.be.true;\n        } catch (_error) {\n          (0, _chai.expect)(true).to.be.true;\n        }\n      });\n      (0, _mocha.describe)('when there is a torii provider in the session data', function () {\n        (0, _mocha.describe)('when torii fetches successfully', function () {\n          (0, _mocha.beforeEach)(function () {\n            sinon.stub(torii, 'fetch').returns(Ember.RSVP.resolve({\n              some: 'other data'\n            }));\n          });\n          (0, _mocha.it)('returns a promise that resolves with the session data merged with the data fetched from torri', async function () {\n            let data = await authenticator.restore({\n              some: 'data',\n              provider: 'provider',\n              another: 'prop'\n            });\n            (0, _chai.expect)(data).to.eql({\n              some: 'other data',\n              provider: 'provider',\n              another: 'prop'\n            });\n          });\n        });\n        (0, _mocha.describe)('when torii does not fetch successfully', function () {\n          (0, _mocha.beforeEach)(function () {\n            sinon.stub(torii, 'fetch').returns(Ember.RSVP.reject());\n          });\n          itDoesNotRestore({\n            some: 'data',\n            provider: 'provider'\n          });\n        });\n      });\n      (0, _mocha.describe)('when there is no torii provider in the session data', function () {\n        itDoesNotRestore();\n      });\n    });\n    (0, _mocha.describe)('#authenticate', function () {\n      (0, _mocha.it)('throws if torii is not installed', async function () {\n        authenticator.set('torii', null);\n\n        try {\n          await authenticator.authenticate();\n          (0, _chai.expect)(false).to.be.true;\n        } catch (_error) {\n          (0, _chai.expect)(true).to.be.true;\n        }\n      });\n      (0, _mocha.describe)('when torii opens successfully', function () {\n        (0, _mocha.beforeEach)(function () {\n          sinon.stub(torii, 'open').returns(Ember.RSVP.resolve({\n            some: 'data'\n          }));\n        });\n        (0, _mocha.it)('returns a promise that resolves with the session data', async function () {\n          let data = await authenticator.authenticate('provider');\n          (0, _chai.expect)(data).to.eql({\n            some: 'data',\n            provider: 'provider'\n          });\n        });\n      });\n      (0, _mocha.describe)('when torii does not open successfully', function () {\n        (0, _mocha.beforeEach)(function () {\n          sinon.stub(torii, 'open').returns(Ember.RSVP.reject());\n        });\n        (0, _mocha.it)('returns a rejecting promise', async function () {\n          try {\n            await authenticator.authenticate('provider');\n            (0, _chai.expect)(false).to.be.true;\n          } catch (_error) {\n            (0, _chai.expect)(true).to.be.true;\n          }\n        });\n      });\n    });\n    (0, _mocha.describe)('#invalidate', function () {\n      (0, _mocha.describe)('when torii closes successfully', function () {\n        (0, _mocha.beforeEach)(function () {\n          sinon.stub(torii, 'close').returns(Ember.RSVP.resolve());\n        });\n        (0, _mocha.it)('returns a resolving promise', async function () {\n          try {\n            await authenticator.invalidate({\n              some: 'data'\n            });\n            (0, _chai.expect)(true).to.be.true;\n          } catch (_error) {\n            (0, _chai.expect)(false).to.be.true;\n          }\n        });\n      });\n      (0, _mocha.describe)('when torii does not close successfully', function () {\n        (0, _mocha.beforeEach)(function () {\n          sinon.stub(torii, 'close').returns(Ember.RSVP.reject());\n        });\n        (0, _mocha.it)('returns a rejecting promise', async function () {\n          try {\n            await authenticator.invalidate({\n              some: 'data'\n            });\n            (0, _chai.expect)(false).to.be.true;\n          } catch (_error) {\n            (0, _chai.expect)(true).to.be.true;\n          }\n        });\n      });\n    });\n  });\n});","define(\"dummy/tests/unit/configuration-test\", [\"mocha\", \"chai\", \"ember-simple-auth/configuration\"], function (_mocha, _chai, _configuration) {\n  \"use strict\";\n\n  (0, _mocha.describe)('Configuration', () => {\n    (0, _mocha.afterEach)(function () {\n      _configuration.default.load({});\n    });\n    (0, _mocha.describe)('rootURL', function () {\n      (0, _mocha.it)('defaults to \"\"', function () {\n        _configuration.default.load({});\n\n        (0, _chai.expect)(_configuration.default.rootURL).to.eql('');\n      });\n    });\n    (0, _mocha.describe)('.load', function () {\n      (0, _mocha.it)('sets rootURL correctly', function () {\n        _configuration.default.load({\n          rootURL: '/rootURL'\n        });\n\n        (0, _chai.expect)(_configuration.default.rootURL).to.eql('/rootURL');\n      });\n    });\n  });\n});","define(\"dummy/tests/unit/initializers/setup-session-restoration-test\", [\"ember-mocha\", \"mocha\", \"chai\", \"sinon\", \"ember-simple-auth/initializers/setup-session-restoration\"], function (_emberMocha, _mocha, _chai, _sinon, _setupSessionRestoration) {\n  \"use strict\";\n\n  (0, _mocha.describe)('setupSessionRestoration', () => {\n    (0, _emberMocha.setupTest)();\n    let sinon;\n    (0, _mocha.beforeEach)(function () {\n      sinon = _sinon.default.createSandbox();\n      this.owner.register('route:application', Ember.Route.extend());\n    });\n    afterEach(function () {\n      sinon.restore();\n    });\n    (0, _mocha.it)('adds a beforeModel method', function () {\n      (0, _setupSessionRestoration.default)(this.owner);\n      const route = this.owner.lookup('route:application');\n      (0, _chai.expect)(route).to.respondTo('beforeModel');\n    });\n    (0, _mocha.describe)('the beforeModel method', function () {\n      let session;\n      let route;\n      (0, _mocha.beforeEach)(function () {\n        this.owner.register('session:main', Ember.Object.extend({\n          restore() {}\n\n        }));\n        session = this.owner.lookup('session:main');\n        this.owner.register('route:application', Ember.Route.extend({\n          beforeModel() {\n            return Ember.RSVP.resolve('test');\n          }\n\n        }));\n        route = this.owner.lookup('route:application');\n        (0, _setupSessionRestoration.default)(this.owner);\n      });\n      (0, _mocha.describe)('when session restoration resolves', function () {\n        (0, _mocha.beforeEach)(function () {\n          sinon.stub(session, 'restore').returns(Ember.RSVP.resolve());\n        });\n        (0, _mocha.it)('returns the return value of the original \"beforeModel\" method', async function () {\n          let value = await route.beforeModel();\n          (0, _chai.expect)(value).to.eq('test');\n        });\n      });\n      (0, _mocha.describe)('when session restoration rejects', function () {\n        (0, _mocha.beforeEach)(function () {\n          sinon.stub(session, 'restore').returns(Ember.RSVP.reject());\n        });\n        (0, _mocha.it)('returns the return value of the original \"beforeModel\" method', async function () {\n          let value = await route.beforeModel();\n          (0, _chai.expect)(value).to.eq('test');\n        });\n      });\n    });\n  });\n});","define(\"dummy/tests/unit/initializers/setup-session-service-test\", [\"mocha\", \"chai\", \"sinon\", \"ember-simple-auth/initializers/setup-session-service\"], function (_mocha, _chai, _sinon, _setupSessionService) {\n  \"use strict\";\n\n  (0, _mocha.describe)('setupSessionService', () => {\n    let sinon;\n    let registry;\n    (0, _mocha.beforeEach)(function () {\n      sinon = _sinon.default.createSandbox();\n      registry = {\n        injection() {}\n\n      };\n    });\n    afterEach(function () {\n      sinon.restore();\n    });\n    (0, _mocha.it)('injects the session into the session service', function () {\n      sinon.spy(registry, 'injection');\n      (0, _setupSessionService.default)(registry);\n      (0, _chai.expect)(registry.injection).to.have.been.calledWith('service:session', 'session', 'session:main');\n    });\n  });\n});","define(\"dummy/tests/unit/initializers/setup-session-test\", [\"mocha\", \"chai\", \"sinon\", \"ember-simple-auth/initializers/setup-session\", \"ember-simple-auth/session-stores/ephemeral\", \"ember-simple-auth/internal-session\"], function (_mocha, _chai, _sinon, _setupSession, _ephemeral, _internalSession) {\n  \"use strict\";\n\n  (0, _mocha.describe)('setupSession', () => {\n    let sinon;\n    let registry;\n    (0, _mocha.beforeEach)(function () {\n      sinon = _sinon.default.createSandbox();\n      registry = {\n        register() {},\n\n        injection() {}\n\n      };\n      Ember.testing = true; // eslint-disable-line ember/no-ember-testing-in-module-scope\n    });\n    (0, _mocha.afterEach)(function () {\n      sinon.restore();\n    });\n    (0, _mocha.it)('registers the session', function () {\n      sinon.spy(registry, 'register');\n      (0, _setupSession.default)(registry);\n      (0, _chai.expect)(registry.register).to.have.been.calledWith('session:main', _internalSession.default);\n    });\n    (0, _mocha.describe)('when Ember.testing is true', function () {\n      (0, _mocha.it)('registers the test session store', function () {\n        sinon.spy(registry, 'register');\n        (0, _setupSession.default)(registry);\n        (0, _chai.expect)(registry.register).to.have.been.calledWith('session-store:test', _ephemeral.default);\n      });\n      (0, _mocha.it)('injects the test session store into the session', function () {\n        sinon.spy(registry, 'injection');\n        (0, _setupSession.default)(registry);\n        (0, _chai.expect)(registry.injection).to.have.been.calledWith('session:main', 'store', 'session-store:test');\n      });\n    });\n    (0, _mocha.describe)('when Ember.testing is false', function () {\n      (0, _mocha.beforeEach)(function () {\n        Ember.testing = false; // eslint-disable-line ember/no-ember-testing-in-module-scope\n      });\n      (0, _mocha.afterEach)(function () {\n        Ember.testing = true; // eslint-disable-line ember/no-ember-testing-in-module-scope\n      });\n      (0, _mocha.it)('injects the application session store into the session', function () {\n        sinon.spy(registry, 'injection');\n        (0, _setupSession.default)(registry);\n        (0, _chai.expect)(registry.injection).to.have.been.calledWith('session:main', 'store', 'session-store:application');\n      });\n    });\n  });\n});","define(\"dummy/tests/unit/internal-session-test\", [\"mocha\", \"ember-mocha\", \"chai\", \"sinon\", \"ember-simple-auth/internal-session\", \"ember-simple-auth/session-stores/ephemeral\", \"ember-simple-auth/authenticators/base\"], function (_mocha, _emberMocha, _chai, _sinon, _internalSession, _ephemeral, _base) {\n  \"use strict\";\n\n  (0, _mocha.describe)('InternalSession', () => {\n    (0, _emberMocha.setupTest)();\n    let sinon;\n    let session;\n    let store;\n    let authenticator;\n    (0, _mocha.beforeEach)(function () {\n      sinon = _sinon.default.createSandbox();\n      store = _ephemeral.default.create();\n      authenticator = _base.default.create();\n      this.owner.register('authenticator:test', authenticator, {\n        instantiate: false\n      });\n      session = _internalSession.default.create({\n        store\n      });\n      Ember.setOwner(session, this.owner);\n    });\n    afterEach(function () {\n      sinon.restore();\n    });\n    (0, _mocha.it)('does not allow data to be stored for the key \"authenticated\"', function () {\n      (0, _chai.expect)(() => {\n        session.set('authenticated', 'test');\n      }).to.throw(Error);\n    });\n\n    function itHandlesAuthenticatorEvents(preparation) {\n      (0, _mocha.describe)('when the authenticator triggers the \"sessionDataUpdated\" event', function () {\n        (0, _mocha.beforeEach)(function () {\n          return preparation.call();\n        });\n        (0, _mocha.it)('stores the data the event is triggered with in its authenticated section', function (done) {\n          authenticator.trigger('sessionDataUpdated', {\n            some: 'property'\n          });\n          Ember.run.next(() => {\n            (0, _chai.expect)(session.get('authenticated')).to.eql({\n              some: 'property',\n              authenticator: 'authenticator:test'\n            });\n            done();\n          });\n        });\n      });\n      (0, _mocha.describe)('when the authenticator triggers the \"invalidated\" event', function () {\n        (0, _mocha.beforeEach)(function () {\n          return preparation.call();\n        });\n        (0, _mocha.it)('is not authenticated', function (done) {\n          authenticator.trigger('sessionDataInvalidated');\n          Ember.run.next(() => {\n            (0, _chai.expect)(session.get('isAuthenticated')).to.be.false;\n            done();\n          });\n        });\n        (0, _mocha.it)('clears its authenticated section', function (done) {\n          session.set('content', {\n            some: 'property',\n            authenticated: {\n              some: 'other property'\n            }\n          });\n          authenticator.trigger('sessionDataInvalidated');\n          Ember.run.next(() => {\n            (0, _chai.expect)(session.get('content')).to.eql({\n              some: 'property',\n              authenticated: {}\n            });\n            done();\n          });\n        });\n        (0, _mocha.it)('updates the store', function (done) {\n          authenticator.trigger('sessionDataInvalidated');\n          Ember.run.next(async () => {\n            let properties = await store.restore();\n            (0, _chai.expect)(properties.authenticated).to.eql({});\n            done();\n          });\n        });\n        (0, _mocha.it)('triggers the \"invalidationSucceeded\" event', function (done) {\n          let triggered = false;\n          session.one('invalidationSucceeded', () => {\n            triggered = true;\n          });\n          authenticator.trigger('sessionDataInvalidated');\n          Ember.run.next(() => {\n            (0, _chai.expect)(triggered).to.be.true;\n            done();\n          });\n        });\n      });\n    }\n\n    (0, _mocha.describe)('restore', function () {\n      function itDoesNotRestore() {\n        (0, _mocha.it)('returns a rejecting promise', async function () {\n          try {\n            await session.restore();\n            (0, _chai.expect)(false).to.be.true;\n          } catch (_error) {\n            (0, _chai.expect)(true).to.be.true;\n          }\n        });\n        (0, _mocha.it)('is not authenticated', async function () {\n          try {\n            await session.restore();\n          } catch (_error) {\n            (0, _chai.expect)(session.get('isAuthenticated')).to.be.false;\n          }\n        });\n        (0, _mocha.it)('clears its authenticated section', async function () {\n          store.persist({\n            some: 'property',\n            authenticated: {\n              some: 'other property'\n            }\n          });\n\n          try {\n            await session.restore();\n          } catch (_error) {\n            (0, _chai.expect)(session.get('content')).to.eql({\n              some: 'property',\n              authenticated: {}\n            });\n          }\n        });\n      }\n\n      (0, _mocha.describe)('when the restored data contains an authenticator factory', function () {\n        (0, _mocha.beforeEach)(function () {\n          store.persist({\n            authenticated: {\n              authenticator: 'authenticator:test'\n            }\n          });\n        });\n        (0, _mocha.describe)('when the authenticator resolves restoration', function () {\n          (0, _mocha.beforeEach)(function () {\n            sinon.stub(authenticator, 'restore').returns(Ember.RSVP.resolve({\n              some: 'property'\n            }));\n          });\n          (0, _mocha.it)('returns a resolving promise', async function () {\n            try {\n              await session.restore();\n              (0, _chai.expect)(true).to.be.true;\n            } catch (_error) {\n              (0, _chai.expect)(false).to.be.true;\n            }\n          });\n          (0, _mocha.it)('is authenticated', async function () {\n            await session.restore();\n            (0, _chai.expect)(session.get('isAuthenticated')).to.be.true;\n          });\n          (0, _mocha.it)('stores the data the authenticator resolves with in its authenticated section', async function () {\n            await store.persist({\n              authenticated: {\n                authenticator: 'authenticator:test'\n              }\n            });\n            await session.restore();\n            let properties = await store.restore();\n            delete properties.authenticator;\n            (0, _chai.expect)(session.get('authenticated')).to.eql({\n              some: 'property',\n              authenticator: 'authenticator:test'\n            });\n          });\n          (0, _mocha.it)('persists its content in the store', async function () {\n            await store.persist({\n              authenticated: {\n                authenticator: 'authenticator:test'\n              },\n              someOther: 'property'\n            });\n            await session.restore();\n            let properties = await store.restore();\n            delete properties.authenticator;\n            (0, _chai.expect)(properties).to.eql({\n              authenticated: {\n                some: 'property',\n                authenticator: 'authenticator:test'\n              },\n              someOther: 'property'\n            });\n          });\n          (0, _mocha.it)('persists the authenticator factory in the store', async function () {\n            await session.restore();\n            let properties = await store.restore();\n            (0, _chai.expect)(properties.authenticated.authenticator).to.eql('authenticator:test');\n          });\n          (0, _mocha.it)('does not trigger the \"authenticationSucceeded\" event', async function () {\n            let triggered = false;\n            session.one('authenticationSucceeded', () => triggered = true);\n            await session.restore();\n            (0, _chai.expect)(triggered).to.be.false;\n          });\n          itHandlesAuthenticatorEvents(async () => {\n            await session.restore();\n          });\n        });\n        (0, _mocha.describe)('when the authenticator rejects restoration', function () {\n          (0, _mocha.beforeEach)(function () {\n            sinon.stub(authenticator, 'restore').returns(Ember.RSVP.reject());\n          });\n          itDoesNotRestore();\n        });\n      });\n      (0, _mocha.describe)('when the restored data does not contain an authenticator factory', function () {\n        itDoesNotRestore();\n      });\n      (0, _mocha.describe)('when the store rejects restoration', function () {\n        (0, _mocha.beforeEach)(function () {\n          sinon.stub(store, 'restore').returns(Ember.RSVP.Promise.reject());\n        });\n        (0, _mocha.it)('is not authenticated', async function () {\n          await session.restore();\n          (0, _chai.expect)(session.get('isAuthenticated')).to.be.false;\n        });\n      });\n      (0, _mocha.describe)('when the store rejects persistance', function () {\n        (0, _mocha.beforeEach)(function () {\n          sinon.stub(store, 'persist').returns(Ember.RSVP.reject());\n        });\n        (0, _mocha.it)('is not authenticated', async function () {\n          await session.restore();\n          (0, _chai.expect)(session.get('isAuthenticated')).to.be.false;\n        });\n      });\n    });\n    (0, _mocha.describe)('authentication', function () {\n      (0, _mocha.describe)('when the authenticator resolves authentication', function () {\n        (0, _mocha.beforeEach)(function () {\n          sinon.stub(authenticator, 'authenticate').returns(Ember.RSVP.resolve({\n            some: 'property'\n          }));\n        });\n        (0, _mocha.it)('is authenticated', async function () {\n          await session.authenticate('authenticator:test');\n          (0, _chai.expect)(session.get('isAuthenticated')).to.be.true;\n        });\n        (0, _mocha.it)('returns a resolving promise', async function () {\n          try {\n            await session.authenticate('authenticator:test');\n            (0, _chai.expect)(true).to.be.true;\n          } catch (_error) {\n            (0, _chai.expect)(false).to.be.true;\n          }\n        });\n        (0, _mocha.it)('stores the data the authenticator resolves with in its authenticated section', async function () {\n          await session.authenticate('authenticator:test');\n          (0, _chai.expect)(session.get('authenticated')).to.eql({\n            some: 'property',\n            authenticator: 'authenticator:test'\n          });\n        });\n        (0, _mocha.it)('persists its content in the store', async function () {\n          await session.authenticate('authenticator:test');\n          let properties = await store.restore();\n          delete properties.authenticator;\n          (0, _chai.expect)(properties).to.eql({\n            authenticated: {\n              some: 'property',\n              authenticator: 'authenticator:test'\n            }\n          });\n        });\n        (0, _mocha.it)('persists the authenticator factory in the store', async function () {\n          await session.authenticate('authenticator:test');\n          let properties = await store.restore();\n          (0, _chai.expect)(properties.authenticated.authenticator).to.eql('authenticator:test');\n        });\n        (0, _mocha.it)('triggers the \"authenticationSucceeded\" event', async function () {\n          let triggered = false;\n          session.one('authenticationSucceeded', () => triggered = true);\n          await session.authenticate('authenticator:test');\n          (0, _chai.expect)(triggered).to.be.true;\n        });\n        itHandlesAuthenticatorEvents(async () => {\n          await session.authenticate('authenticator:test');\n        });\n      });\n      (0, _mocha.describe)('when the authenticator rejects authentication', function () {\n        (0, _mocha.it)('is not authenticated', async function () {\n          sinon.stub(authenticator, 'authenticate').returns(Ember.RSVP.reject('error auth'));\n\n          try {\n            await session.authenticate('authenticator:test');\n          } catch (_error) {\n            (0, _chai.expect)(session.get('isAuthenticated')).to.be.false;\n          }\n        });\n        (0, _mocha.it)('returns a rejecting promise', async function () {\n          sinon.stub(authenticator, 'authenticate').returns(Ember.RSVP.reject('error auth'));\n\n          try {\n            await session.authenticate('authenticator:test');\n            (0, _chai.expect)(false).to.be.true;\n          } catch (_error) {\n            (0, _chai.expect)(true).to.be.true;\n          }\n        });\n        (0, _mocha.it)('clears its authenticated section', async function () {\n          sinon.stub(authenticator, 'authenticate').returns(Ember.RSVP.reject('error auth'));\n          session.set('content', {\n            some: 'property',\n            authenticated: {\n              some: 'other property'\n            }\n          });\n\n          try {\n            await session.authenticate('authenticator:test');\n          } catch (_error) {\n            (0, _chai.expect)(session.get('content')).to.eql({\n              some: 'property',\n              authenticated: {}\n            });\n          }\n        });\n        (0, _mocha.it)('updates the store', async function () {\n          sinon.stub(authenticator, 'authenticate').returns(Ember.RSVP.reject('error auth'));\n          session.set('content', {\n            some: 'property',\n            authenticated: {\n              some: 'other property'\n            }\n          });\n\n          try {\n            await session.authenticate('authenticator:test');\n          } catch (_error) {\n            let properties = await store.restore();\n            (0, _chai.expect)(properties).to.eql({\n              some: 'property',\n              authenticated: {}\n            });\n          }\n        });\n        (0, _mocha.it)('does not trigger the \"authenticationSucceeded\" event', async function () {\n          let triggered = false;\n          sinon.stub(authenticator, 'authenticate').returns(Ember.RSVP.reject('error auth'));\n          session.one('authenticationSucceeded', () => triggered = true);\n\n          try {\n            await session.authenticate('authenticator:test');\n          } catch (_error) {\n            (0, _chai.expect)(triggered).to.be.false;\n          }\n        });\n      });\n      (0, _mocha.describe)('when the store rejects persistance', function () {\n        (0, _mocha.beforeEach)(function () {\n          sinon.stub(store, 'persist').returns(Ember.RSVP.reject());\n        });\n        (0, _mocha.it)('is not authenticated', async function () {\n          await session.authenticate('authenticator:test');\n          (0, _chai.expect)(session.get('isAuthenticated')).to.be.false;\n        });\n      });\n    });\n    (0, _mocha.describe)('invalidation', function () {\n      (0, _mocha.beforeEach)(async function () {\n        sinon.stub(authenticator, 'authenticate').returns(Ember.RSVP.resolve({\n          some: 'property'\n        }));\n        await session.authenticate('authenticator:test');\n      });\n      (0, _mocha.describe)('when invalidate gets called with additional params', function () {\n        (0, _mocha.beforeEach)(function () {\n          sinon.spy(authenticator, 'invalidate');\n        });\n        (0, _mocha.it)('passes the params on to the authenticators invalidate method', function () {\n          let param = {\n            some: 'random data'\n          };\n          session.invalidate(param);\n          (0, _chai.expect)(authenticator.invalidate).to.have.been.calledWith(session.get('authenticated'), param);\n        });\n      });\n      (0, _mocha.describe)('when the authenticator resolves invalidation', function () {\n        (0, _mocha.beforeEach)(function () {\n          sinon.stub(authenticator, 'invalidate').returns(Ember.RSVP.resolve());\n        });\n        (0, _mocha.it)('is not authenticated', async function () {\n          await session.invalidate();\n          (0, _chai.expect)(session.get('isAuthenticated')).to.be.false;\n        });\n        (0, _mocha.it)('returns a resolving promise', async function () {\n          try {\n            await session.invalidate();\n            (0, _chai.expect)(true).to.be.true;\n          } catch (_error) {\n            (0, _chai.expect)(false).to.be.true;\n          }\n        });\n        (0, _mocha.it)('clears its authenticated section', async function () {\n          session.set('content', {\n            some: 'property',\n            authenticated: {\n              some: 'other property'\n            }\n          });\n          await session.invalidate();\n          (0, _chai.expect)(session.get('content')).to.eql({\n            some: 'property',\n            authenticated: {}\n          });\n        });\n        (0, _mocha.it)('updates the store', async function () {\n          session.set('content', {\n            some: 'property',\n            authenticated: {\n              some: 'other property'\n            }\n          });\n          await session.invalidate();\n          let properties = await store.restore();\n          (0, _chai.expect)(properties).to.eql({\n            some: 'property',\n            authenticated: {}\n          });\n        });\n        (0, _mocha.it)('triggers the \"invalidationSucceeded\" event', async function () {\n          let triggered = false;\n          session.one('invalidationSucceeded', () => triggered = true);\n          await session.invalidate();\n          (0, _chai.expect)(triggered).to.be.true;\n        });\n      });\n      (0, _mocha.describe)('when the authenticator rejects invalidation', function () {\n        (0, _mocha.it)('stays authenticated', async function () {\n          sinon.stub(authenticator, 'invalidate').returns(Ember.RSVP.reject('error'));\n\n          try {\n            await session.invalidate();\n          } catch (_error) {\n            (0, _chai.expect)(session.get('isAuthenticated')).to.be.true;\n          }\n        });\n        (0, _mocha.it)('returns a rejecting promise', async function () {\n          sinon.stub(authenticator, 'invalidate').returns(Ember.RSVP.reject('error'));\n\n          try {\n            await session.invalidate();\n            (0, _chai.expect)(false).to.be.true;\n          } catch (_error) {\n            (0, _chai.expect)(true).to.be.true;\n          }\n        });\n        (0, _mocha.it)('keeps its content', async function () {\n          sinon.stub(authenticator, 'invalidate').returns(Ember.RSVP.reject('error'));\n\n          try {\n            await session.invalidate();\n          } catch (_error) {\n            (0, _chai.expect)(session.get('authenticated')).to.eql({\n              some: 'property',\n              authenticator: 'authenticator:test'\n            });\n          }\n        });\n        (0, _mocha.it)('does not update the store', async function () {\n          sinon.stub(authenticator, 'invalidate').returns(Ember.RSVP.reject('error'));\n\n          try {\n            await session.invalidate();\n          } catch (_error) {\n            let properties = await store.restore();\n            (0, _chai.expect)(properties).to.eql({\n              authenticated: {\n                some: 'property',\n                authenticator: 'authenticator:test'\n              }\n            });\n          }\n        });\n        (0, _mocha.it)('does not trigger the \"invalidationSucceeded\" event', async function () {\n          sinon.stub(authenticator, 'invalidate').returns(Ember.RSVP.reject('error'));\n          let triggered = false;\n          session.one('invalidationSucceeded', () => triggered = true);\n\n          try {\n            await session.invalidate();\n          } catch (_error) {\n            (0, _chai.expect)(triggered).to.be.false;\n          }\n        });\n        itHandlesAuthenticatorEvents(function () {});\n      });\n      (0, _mocha.describe)('when the store rejects persistance', function () {\n        (0, _mocha.beforeEach)(function () {\n          sinon.stub(store, 'persist').returns(Ember.RSVP.reject());\n        });\n        (0, _mocha.it)('rejects but is not authenticated', async function () {\n          try {\n            await session.invalidate();\n          } catch (_error) {\n            (0, _chai.expect)(session.get('isAuthenticated')).to.be.false;\n          }\n        });\n      });\n    });\n    (0, _mocha.describe)(\"when the session's content changes\", function () {\n      (0, _mocha.describe)('when a single property is set', function () {\n        (0, _mocha.describe)('when the property is private (starts with an \"_\")', function () {\n          (0, _mocha.beforeEach)(function () {\n            session.set('_some', 'property');\n          });\n          (0, _mocha.it)('does not persist its content in the store', async function () {\n            let properties = await store.restore();\n            delete properties.authenticator;\n            (0, _chai.expect)(properties).to.eql({});\n          });\n        });\n        (0, _mocha.describe)('when the property is not private (does not start with an \"_\")', function () {\n          (0, _mocha.beforeEach)(function () {\n            session.set('some', 'property');\n          });\n          (0, _mocha.it)('persists its content in the store', async function () {\n            let properties = await store.restore();\n            delete properties.authenticator;\n            (0, _chai.expect)(properties).to.eql({\n              some: 'property',\n              authenticated: {}\n            });\n          });\n        });\n      });\n      (0, _mocha.describe)('when multiple properties are set at once', function () {\n        (0, _mocha.beforeEach)(function () {\n          session.set('some', 'property');\n          session.setProperties({\n            another: 'property',\n            multiple: 'properties'\n          });\n        });\n        (0, _mocha.it)('persists its content in the store', async function () {\n          let properties = await store.restore();\n          delete properties.authenticator;\n          (0, _chai.expect)(properties).to.eql({\n            some: 'property',\n            another: 'property',\n            multiple: 'properties',\n            authenticated: {}\n          });\n        });\n      });\n    });\n    (0, _mocha.describe)('when the store triggers the \"sessionDataUpdated\" event', function () {\n      (0, _mocha.describe)('when the session is currently busy', function () {\n        (0, _mocha.beforeEach)(function () {\n          sinon.stub(store, 'restore').returns(new Ember.RSVP.Promise(resolve => {\n            Ember.run.next(() => resolve({\n              some: 'other property'\n            }));\n          }));\n        });\n        (0, _mocha.it)('does not process the event', async function () {\n          sinon.spy(authenticator, 'restore');\n          let restoration = session.restore();\n          store.trigger('sessionDataUpdated', {\n            some: 'other property',\n            authenticated: {\n              authenticator: 'authenticator:test'\n            }\n          });\n          await restoration;\n          (0, _chai.expect)(authenticator.restore).to.not.have.been.called;\n        });\n      });\n      (0, _mocha.describe)('when the session is not currently busy', function () {\n        (0, _mocha.describe)('when there is an authenticator factory in the event data', function () {\n          (0, _mocha.describe)('when the authenticator resolves restoration', function () {\n            (0, _mocha.beforeEach)(function () {\n              sinon.stub(authenticator, 'restore').returns(Ember.RSVP.resolve({\n                some: 'other property'\n              }));\n            });\n            (0, _mocha.it)('is authenticated', function (done) {\n              store.trigger('sessionDataUpdated', {\n                some: 'other property',\n                authenticated: {\n                  authenticator: 'authenticator:test'\n                }\n              });\n              Ember.run.next(() => {\n                (0, _chai.expect)(session.get('isAuthenticated')).to.be.true;\n                done();\n              });\n            });\n            (0, _mocha.it)('stores the data the authenticator resolves with in its authenticated section', function (done) {\n              store.trigger('sessionDataUpdated', {\n                some: 'property',\n                authenticated: {\n                  authenticator: 'authenticator:test'\n                }\n              });\n              Ember.run.next(() => {\n                (0, _chai.expect)(session.get('authenticated')).to.eql({\n                  some: 'other property',\n                  authenticator: 'authenticator:test'\n                });\n                done();\n              });\n            });\n            (0, _mocha.it)('persists its content in the store', function (done) {\n              store.trigger('sessionDataUpdated', {\n                some: 'property',\n                authenticated: {\n                  authenticator: 'authenticator:test'\n                }\n              });\n              Ember.run.next(async () => {\n                let properties = await store.restore();\n                (0, _chai.expect)(properties).to.eql({\n                  some: 'property',\n                  authenticated: {\n                    some: 'other property',\n                    authenticator: 'authenticator:test'\n                  }\n                });\n                done();\n              });\n            });\n            (0, _mocha.describe)('when the session is already authenticated', function () {\n              (0, _mocha.beforeEach)(function () {\n                session.set('isAuthenticated', true);\n              });\n              (0, _mocha.it)('does not trigger the \"authenticationSucceeded\" event', function (done) {\n                let triggered = false;\n                session.one('authenticationSucceeded', () => triggered = true);\n                store.trigger('sessionDataUpdated', {\n                  some: 'other property',\n                  authenticated: {\n                    authenticator: 'authenticator:test'\n                  }\n                });\n                Ember.run.next(() => {\n                  (0, _chai.expect)(triggered).to.be.false;\n                  done();\n                });\n              });\n            });\n            (0, _mocha.describe)('when the session is not already authenticated', function () {\n              (0, _mocha.beforeEach)(function () {\n                session.set('isAuthenticated', false);\n              });\n              (0, _mocha.it)('triggers the \"authenticationSucceeded\" event', function (done) {\n                let triggered = false;\n                session.one('authenticationSucceeded', () => triggered = true);\n                store.trigger('sessionDataUpdated', {\n                  some: 'other property',\n                  authenticated: {\n                    authenticator: 'authenticator:test'\n                  }\n                });\n                Ember.run.next(() => {\n                  (0, _chai.expect)(triggered).to.be.true;\n                  done();\n                });\n              });\n            });\n          });\n          (0, _mocha.describe)('when the authenticator rejects restoration', function () {\n            (0, _mocha.beforeEach)(function () {\n              sinon.stub(authenticator, 'restore').returns(Ember.RSVP.reject());\n            });\n            (0, _mocha.it)('is not authenticated', function (done) {\n              store.trigger('sessionDataUpdated', {\n                some: 'other property',\n                authenticated: {\n                  authenticator: 'authenticator:test'\n                }\n              });\n              Ember.run.next(() => {\n                (0, _chai.expect)(session.get('isAuthenticated')).to.be.false;\n                done();\n              });\n            });\n            (0, _mocha.it)('clears its authenticated section', function (done) {\n              session.set('content', {\n                some: 'property',\n                authenticated: {\n                  some: 'other property'\n                }\n              });\n              store.trigger('sessionDataUpdated', {\n                some: 'other property',\n                authenticated: {\n                  authenticator: 'authenticator:test'\n                }\n              });\n              Ember.run.next(() => {\n                (0, _chai.expect)(session.get('content')).to.eql({\n                  some: 'other property',\n                  authenticated: {}\n                });\n                done();\n              });\n            });\n            (0, _mocha.it)('updates the store', function (done) {\n              session.set('content', {\n                some: 'property',\n                authenticated: {\n                  some: 'other property'\n                }\n              });\n              store.trigger('sessionDataUpdated', {\n                some: 'other property',\n                authenticated: {\n                  authenticator: 'authenticator:test'\n                }\n              });\n              Ember.run.next(async () => {\n                let properties = await store.restore();\n                (0, _chai.expect)(properties).to.eql({\n                  some: 'other property',\n                  authenticated: {}\n                });\n                done();\n              });\n            });\n            (0, _mocha.describe)('when the session is authenticated', function () {\n              (0, _mocha.beforeEach)(function () {\n                session.set('isAuthenticated', true);\n              });\n              (0, _mocha.it)('triggers the \"invalidationSucceeded\" event', function (done) {\n                let triggered = false;\n                session.one('invalidationSucceeded', () => triggered = true);\n                store.trigger('sessionDataUpdated', {\n                  some: 'other property',\n                  authenticated: {\n                    authenticator: 'authenticator:test'\n                  }\n                });\n                Ember.run.next(() => {\n                  (0, _chai.expect)(triggered).to.be.true;\n                  done();\n                });\n              });\n            });\n            (0, _mocha.describe)('when the session is not authenticated', function () {\n              (0, _mocha.beforeEach)(function () {\n                session.set('isAuthenticated', false);\n              });\n              (0, _mocha.it)('does not trigger the \"invalidationSucceeded\" event', function (done) {\n                let triggered = false;\n                session.one('invalidationSucceeded', () => triggered = true);\n                store.trigger('sessionDataUpdated', {\n                  some: 'other property',\n                  authenticated: {\n                    authenticator: 'authenticator:test'\n                  }\n                });\n                Ember.run.next(() => {\n                  (0, _chai.expect)(triggered).to.be.false;\n                  done();\n                });\n              });\n            });\n          });\n        });\n        (0, _mocha.describe)('when there is no authenticator factory in the store', function () {\n          (0, _mocha.it)('is not authenticated', function (done) {\n            store.trigger('sessionDataUpdated', {\n              some: 'other property'\n            });\n            Ember.run.next(() => {\n              (0, _chai.expect)(session.get('isAuthenticated')).to.be.false;\n              done();\n            });\n          });\n          (0, _mocha.it)('clears its authenticated section', function (done) {\n            session.set('content', {\n              some: 'property',\n              authenticated: {\n                some: 'other property'\n              }\n            });\n            store.trigger('sessionDataUpdated', {\n              some: 'other property'\n            });\n            Ember.run.next(() => {\n              (0, _chai.expect)(session.get('content')).to.eql({\n                some: 'other property',\n                authenticated: {}\n              });\n              done();\n            });\n          });\n          (0, _mocha.it)('updates the store', function (done) {\n            session.set('content', {\n              some: 'property',\n              authenticated: {\n                some: 'other property'\n              }\n            });\n            store.trigger('sessionDataUpdated', {\n              some: 'other property'\n            });\n            Ember.run.next(async () => {\n              let properties = await store.restore();\n              (0, _chai.expect)(properties).to.eql({\n                some: 'other property',\n                authenticated: {}\n              });\n              done();\n            });\n          });\n          (0, _mocha.describe)('when the session is authenticated', function () {\n            (0, _mocha.beforeEach)(function () {\n              session.set('isAuthenticated', true);\n            });\n            (0, _mocha.it)('triggers the \"invalidationSucceeded\" event', function (done) {\n              let triggered = false;\n              session.one('invalidationSucceeded', () => triggered = true);\n              store.trigger('sessionDataUpdated', {\n                some: 'other property'\n              });\n              Ember.run.next(() => {\n                (0, _chai.expect)(triggered).to.be.true;\n                done();\n              });\n            });\n          });\n          (0, _mocha.describe)('when the session is not authenticated', function () {\n            (0, _mocha.beforeEach)(function () {\n              session.set('isAuthenticated', false);\n            });\n            (0, _mocha.it)('does not trigger the \"invalidationSucceeded\" event', function (done) {\n              let triggered = false;\n              session.one('invalidationSucceeded', () => triggered = true);\n              store.trigger('sessionDataUpdated', {\n                some: 'other property'\n              });\n              Ember.run.next(() => {\n                (0, _chai.expect)(triggered).to.be.false;\n                done();\n              });\n            });\n            (0, _mocha.it)('it does not trigger the \"sessionInvalidationFailed\" event', async function () {\n              let triggered = false;\n              session.one('sessionInvalidationFailed', () => triggered = true);\n              await session.invalidate();\n              (0, _chai.expect)(triggered).to.be.false;\n            });\n            (0, _mocha.it)('it returns with a resolved Promise', async function () {\n              try {\n                await session.invalidate();\n                (0, _chai.expect)(true).to.be.true;\n              } catch (_error) {\n                (0, _chai.expect)(false).to.be.true;\n              }\n            });\n          });\n        });\n      });\n    });\n    (0, _mocha.it)('does not share the content object between multiple instances', function () {\n      let session2 = _internalSession.default.create({\n        store\n      });\n\n      Ember.setOwner(session2, this.owner);\n      (0, _chai.expect)(session2.get('content')).to.not.equal(session.get('content'));\n    });\n  });\n});","define(\"dummy/tests/unit/mixins/application-route-mixin-test\", [\"mocha\", \"ember-mocha\", \"chai\", \"sinon\", \"ember-simple-auth/internal-session\", \"ember-simple-auth/session-stores/ephemeral\"], function (_mocha, _emberMocha, _chai, _sinon, _internalSession, _ephemeral) {\n  \"use strict\";\n\n  (0, _mocha.describe)('ApplicationRouteMixin', () => {\n    (0, _emberMocha.setupTest)();\n    let sinon;\n    let session;\n    let sessionService;\n    let route;\n    (0, _mocha.beforeEach)(function () {\n      sinon = _sinon.default.createSandbox();\n      session = _internalSession.default.create({\n        store: _ephemeral.default.create()\n      });\n      sessionService = this.owner.lookup('service:session');\n      sessionService.set('session', session);\n      this.owner.register('service:cookies', Ember.Service.extend({\n        read: sinon.stub(),\n        clear: sinon.stub()\n      }));\n      route = this.owner.lookup('route:application');\n      sinon.stub(route, 'transitionTo');\n    });\n    afterEach(function () {\n      sinon.restore();\n    });\n    (0, _mocha.describe)('mapping of service events to route methods', function () {\n      (0, _mocha.beforeEach)(function () {\n        sinon.spy(route, 'sessionAuthenticated');\n        sinon.spy(route, 'sessionInvalidated');\n        sinon.stub(route, '_refresh');\n      });\n      afterEach(function () {\n        sinon.restore();\n      });\n      (0, _mocha.it)(\"maps the services's 'authenticationSucceeded' event into a method call\", function (done) {\n        sessionService.trigger('authenticationSucceeded');\n        Ember.run.next(() => {\n          (0, _chai.expect)(route.sessionAuthenticated).to.have.been.calledOnce;\n          done();\n        });\n      });\n      (0, _mocha.it)(\"maps the services's 'invalidationSucceeded' event into a method call\", function (done) {\n        sessionService.trigger('invalidationSucceeded');\n        Ember.run.next(() => {\n          (0, _chai.expect)(route.sessionInvalidated).to.have.been.calledOnce;\n          done();\n        });\n      });\n      (0, _mocha.it)('does not attach the event listeners twice', function (done) {\n        route.beforeModel();\n        sessionService.trigger('authenticationSucceeded');\n        Ember.run.next(() => {\n          (0, _chai.expect)(route.sessionAuthenticated).to.have.been.calledOnce;\n          done();\n        });\n      });\n    });\n    (0, _mocha.describe)('sessionAuthenticated', function () {\n      (0, _mocha.describe)('when an attempted transition is stored in the session', function () {\n        let attemptedTransition;\n        (0, _mocha.beforeEach)(function () {\n          attemptedTransition = {\n            retry: sinon.stub()\n          };\n          session.set('attemptedTransition', attemptedTransition);\n        });\n        (0, _mocha.it)('retries that transition', function () {\n          route.sessionAuthenticated();\n          (0, _chai.expect)(attemptedTransition.retry).to.have.been.calledOnce;\n        });\n        (0, _mocha.it)('removes it from the session', function () {\n          route.sessionAuthenticated();\n          (0, _chai.expect)(session.get('attemptedTransition')).to.be.null;\n        });\n      });\n      (0, _mocha.describe)('when a redirect target is stored in a cookie', function () {\n        let cookieName = 'ember_simple_auth-redirectTarget';\n        let targetUrl = 'transition/target/url';\n        let clearStub;\n        (0, _mocha.beforeEach)(function () {\n          clearStub = sinon.stub();\n          this.owner.register('service:cookies', Ember.Service.extend({\n            read() {\n              return targetUrl;\n            },\n\n            clear: clearStub\n          }));\n        });\n        (0, _mocha.it)('transitions to the url', function () {\n          route.sessionAuthenticated();\n          (0, _chai.expect)(route.transitionTo).to.have.been.calledWith(targetUrl);\n        });\n        (0, _mocha.it)('clears the cookie', function () {\n          route.sessionAuthenticated();\n          (0, _chai.expect)(clearStub).to.have.been.calledWith(cookieName);\n        });\n      });\n      (0, _mocha.describe)('when no attempted transition is stored in the session', function () {\n        (0, _mocha.it)('transitions to \"index\" by default', function () {\n          route.sessionAuthenticated();\n          (0, _chai.expect)(route.transitionTo).to.have.been.calledWith('index');\n        });\n        (0, _mocha.it)('transitions to \"routeAfterAuthentication\"', function () {\n          let routeAfterAuthentication = 'path/to/route';\n          route.set('routeAfterAuthentication', routeAfterAuthentication);\n          route.sessionAuthenticated();\n          (0, _chai.expect)(route.transitionTo).to.have.been.calledWith(routeAfterAuthentication);\n        });\n      });\n    });\n  });\n});","define(\"dummy/tests/unit/mixins/authenticated-route-mixin-test\", [\"mocha\", \"ember-mocha\", \"chai\", \"sinon\", \"ember-simple-auth/mixins/authenticated-route-mixin\"], function (_mocha, _emberMocha, _chai, _sinon, _authenticatedRouteMixin) {\n  \"use strict\";\n\n  (0, _mocha.describe)('AuthenticatedRouteMixin', () => {\n    (0, _emberMocha.setupTest)();\n    let sinon;\n    let route;\n    let router;\n    let transition;\n    (0, _mocha.beforeEach)(function () {\n      sinon = _sinon.default.createSandbox();\n    });\n    afterEach(function () {\n      sinon.restore();\n    });\n    (0, _mocha.describe)('#beforeModel', function () {\n      (0, _mocha.beforeEach)(function () {\n        const MixinImplementingBeforeModel = Ember.Mixin.create({\n          beforeModel() {\n            return Ember.RSVP.resolve('upstreamReturnValue');\n          }\n\n        });\n        transition = {\n          intent: {\n            url: '/transition/target/url'\n          },\n\n          send() {}\n\n        };\n        this.owner.register('service:router', Ember.Service.extend({\n          transitionTo() {}\n\n        }));\n        router = this.owner.lookup('service:router');\n        this.owner.register('service:session', Ember.Service.extend());\n        route = Ember.Route.extend(MixinImplementingBeforeModel, _authenticatedRouteMixin.default).create();\n        Ember.setOwner(route, this.owner);\n        sinon.spy(transition, 'send');\n        sinon.spy(router, 'transitionTo');\n      });\n      (0, _mocha.describe)('if the session is authenticated', function () {\n        (0, _mocha.beforeEach)(function () {\n          let session = this.owner.lookup('service:session');\n          session.set('isAuthenticated', true);\n        });\n        (0, _mocha.it)('returns the upstream promise', async function () {\n          let result = await route.beforeModel(transition);\n          (0, _chai.expect)(result).to.equal('upstreamReturnValue');\n        });\n        (0, _mocha.it)('does not transition to the authentication route', function () {\n          route.beforeModel(transition);\n          (0, _chai.expect)(router.transitionTo).to.not.have.been.calledWith('login');\n        });\n      });\n      (0, _mocha.describe)('if the session is not authenticated', function () {\n        (0, _mocha.it)('does not return the upstream promise', function () {\n          (0, _chai.expect)(route.beforeModel(transition)).to.be.undefined;\n        });\n        (0, _mocha.it)('transitions to \"login\" as the default authentication route', function () {\n          route.beforeModel(transition);\n          (0, _chai.expect)(router.transitionTo).to.have.been.calledWith('login');\n        });\n        (0, _mocha.it)('transitions to the set authentication route', function () {\n          let authenticationRoute = 'path/to/route';\n          route.set('authenticationRoute', authenticationRoute);\n          route.beforeModel(transition);\n          (0, _chai.expect)(router.transitionTo).to.have.been.calledWith(authenticationRoute);\n        });\n        (0, _mocha.it)('sets the redirectTarget cookie in fastboot', function () {\n          this.owner.register('service:fastboot', Ember.Service.extend({\n            isFastBoot: true,\n\n            init() {\n              this._super(...arguments);\n\n              this.request = {\n                protocol: 'https'\n              };\n            }\n\n          }));\n          let writeCookieStub = sinon.stub();\n          this.owner.register('service:cookies', Ember.Service.extend({\n            write: writeCookieStub\n          }));\n          let cookieName = 'ember_simple_auth-redirectTarget';\n          route.beforeModel(transition);\n          (0, _chai.expect)(writeCookieStub).to.have.been.calledWith(cookieName, transition.intent.url, {\n            path: '/',\n            secure: true\n          });\n        });\n      });\n    });\n  });\n});","define(\"dummy/tests/unit/mixins/data-adapter-mixin-test\", [\"mocha\", \"chai\", \"sinon\", \"ember-simple-auth/mixins/data-adapter-mixin\"], function (_mocha, _chai, _sinon, _dataAdapterMixin) {\n  \"use strict\";\n\n  (0, _mocha.describe)('DataAdapterMixin', () => {\n    let sinon;\n    let adapter;\n    let sessionService;\n    let Adapter;\n    (0, _mocha.beforeEach)(function () {\n      sinon = _sinon.default.createSandbox();\n      sessionService = Ember.Object.create({\n        authorize() {},\n\n        invalidate() {}\n\n      });\n      const BaseAdapter = Ember.Object.extend({\n        handleResponse() {\n          return '_super return value';\n        }\n\n      });\n      Adapter = BaseAdapter.extend(_dataAdapterMixin.default, {});\n      adapter = Adapter.create({\n        session: sessionService\n      });\n    });\n    afterEach(function () {\n      sinon.restore();\n    });\n    (0, _mocha.describe)('#handleResponse', function () {\n      (0, _mocha.beforeEach)(function () {\n        sinon.spy(sessionService, 'invalidate');\n      });\n      (0, _mocha.describe)('when the response status is 401', function () {\n        (0, _mocha.describe)('when the session is authenticated', function () {\n          (0, _mocha.beforeEach)(function () {\n            sessionService.set('isAuthenticated', true);\n          });\n          (0, _mocha.it)('invalidates the session', function () {\n            adapter.handleResponse(401);\n            (0, _chai.expect)(sessionService.invalidate).to.have.been.calledOnce;\n          });\n        });\n        (0, _mocha.describe)('when the session is not authenticated', function () {\n          (0, _mocha.beforeEach)(function () {\n            sessionService.set('isAuthenticated', false);\n          });\n          (0, _mocha.it)('does not invalidate the session', function () {\n            adapter.handleResponse(401);\n            (0, _chai.expect)(sessionService.invalidate).to.not.have.been.called;\n          });\n        });\n      });\n      (0, _mocha.describe)('when the response status is not 401', function () {\n        (0, _mocha.it)('does not invalidate the session', function () {\n          adapter.handleResponse(200);\n          (0, _chai.expect)(sessionService.invalidate).to.not.have.been.called;\n        });\n      });\n      (0, _mocha.describe)('when called via _super, and ensureResponseAuthorized is overridden', function () {\n        let returnValue;\n        (0, _mocha.beforeEach)(function () {\n          const DoesntInvalidateOn401 = Adapter.extend({\n            ensureResponseAuthorized() {// no op, doesn't call this.get('session').invalidate();\n            },\n\n            handleResponse() {\n              return this._super();\n            }\n\n          });\n          adapter = DoesntInvalidateOn401.create();\n          returnValue = adapter.handleResponse(401);\n        });\n        (0, _mocha.it)(\"doesn't invalidate the session (ensureResponseAuthorized can be overridden)\", function () {\n          (0, _chai.expect)(sessionService.invalidate).to.not.have.been.called;\n        });\n        (0, _mocha.it)(\"returns _super's return value\", function () {\n          (0, _chai.expect)(returnValue).to.eq('_super return value');\n        });\n      });\n      (0, _mocha.it)(\"returns _super's return value\", function () {\n        (0, _chai.expect)(adapter.handleResponse(401)).to.eq('_super return value');\n      });\n    });\n  });\n});","define(\"dummy/tests/unit/mixins/oauth2-implicit-grant-callback-route-mixin-test\", [\"ember-mocha\", \"mocha\", \"chai\", \"sinon\", \"ember-simple-auth/mixins/oauth2-implicit-grant-callback-route-mixin\", \"ember-simple-auth/utils/location\"], function (_emberMocha, _mocha, _chai, _sinon, _oauth2ImplicitGrantCallbackRouteMixin, LocationUtil) {\n  \"use strict\";\n\n  (0, _mocha.describe)('OAuth2ImplicitGrantCallbackRouteMixin', function () {\n    (0, _emberMocha.setupTest)();\n    let sinon;\n    let route;\n    let session;\n    (0, _mocha.beforeEach)(function () {\n      sinon = _sinon.default.createSandbox();\n    });\n    (0, _mocha.afterEach)(function () {\n      sinon.restore();\n    });\n    (0, _mocha.describe)('#activate', function () {\n      (0, _mocha.beforeEach)(function () {\n        session = Ember.Object.extend({\n          authenticate(authenticator, hash) {\n            if (!Ember.isEmpty(hash.access_token)) {\n              return Ember.RSVP.resolve();\n            } else {\n              return Ember.RSVP.reject('access_denied');\n            }\n          }\n\n        }).create();\n        sinon.spy(session, 'authenticate');\n        route = Ember.Route.extend(_oauth2ImplicitGrantCallbackRouteMixin.default, {\n          authenticator: 'authenticator:oauth2',\n          _isFastBoot: false\n        }).create({\n          session\n        });\n        Ember.setOwner(route, this.owner);\n        sinon.spy(route, 'transitionTo');\n      });\n      (0, _emberMocha.it)('correctly passes the auth parameters if authentication succeeds', function (done) {\n        // it isn't possible to stub window.location.hash so we stub a wrapper function instead\n        sinon.stub(LocationUtil, 'default').returns({\n          hash: '#/routepath#access_token=secret-token'\n        });\n        route.activate();\n        setTimeout(() => {\n          (0, _chai.expect)(session.authenticate).to.have.been.calledWith('authenticator:oauth2', {\n            access_token: 'secret-token'\n          });\n          done();\n        }, 10);\n      });\n      (0, _emberMocha.it)('saves the error and transition if authentication fails', function (done) {\n        route.activate();\n        setTimeout(() => {\n          (0, _chai.expect)(route.error).to.eq('access_denied');\n          (0, _chai.expect)(session.authenticate).to.have.been.calledWith('authenticator:oauth2');\n          done();\n        }, 10);\n      });\n    });\n  });\n});","define(\"dummy/tests/unit/mixins/unauthenticated-route-mixin-test\", [\"mocha\", \"ember-mocha\", \"chai\", \"sinon\", \"ember-simple-auth/mixins/unauthenticated-route-mixin\"], function (_mocha, _emberMocha, _chai, _sinon, _unauthenticatedRouteMixin) {\n  \"use strict\";\n\n  (0, _mocha.describe)('UnauthenticatedRouteMixin', () => {\n    (0, _emberMocha.setupTest)();\n    let sinon;\n    let route;\n    (0, _mocha.beforeEach)(function () {\n      sinon = _sinon.default.createSandbox();\n    });\n    afterEach(function () {\n      sinon.restore();\n    });\n    (0, _mocha.describe)('#beforeModel', function () {\n      (0, _mocha.beforeEach)(function () {\n        const MixinImplementingBeforeModel = Ember.Mixin.create({\n          beforeModel() {\n            return Ember.RSVP.resolve('upstreamReturnValue');\n          }\n\n        });\n        this.owner.register('service:session', Ember.Service.extend());\n        route = Ember.Route.extend(MixinImplementingBeforeModel, _unauthenticatedRouteMixin.default, {\n          // pretend this is never FastBoot\n          // replace actual transitionTo as the router isn't set up etc.\n          transitionTo() {}\n\n        }).create();\n        Ember.setOwner(route, this.owner);\n        sinon.spy(route, 'transitionTo');\n      });\n      (0, _mocha.describe)('if the session is authenticated', function () {\n        (0, _mocha.beforeEach)(function () {\n          let session = this.owner.lookup('service:session');\n          session.set('isAuthenticated', true);\n        });\n        (0, _mocha.it)('transitions to \"index\" by default', function () {\n          route.beforeModel();\n          (0, _chai.expect)(route.transitionTo).to.have.been.calledWith('index');\n        });\n        (0, _mocha.it)('transitions to set routeIfAlreadyAuthenticated', function () {\n          let routeIfAlreadyAuthenticated = 'path/to/route';\n          route.set('routeIfAlreadyAuthenticated', routeIfAlreadyAuthenticated);\n          route.beforeModel();\n          (0, _chai.expect)(route.transitionTo).to.have.been.calledWith(routeIfAlreadyAuthenticated);\n        });\n        (0, _mocha.it)('does not return the upstream promise', function () {\n          (0, _chai.expect)(route.beforeModel()).to.be.undefined;\n        });\n      });\n      (0, _mocha.describe)('if the session is not authenticated', function () {\n        (0, _mocha.it)('does not call route transitionTo', function () {\n          route.beforeModel();\n          (0, _chai.expect)(route.transitionTo).to.not.have.been.called;\n        });\n        (0, _mocha.it)('returns the upstream promise', async function () {\n          let result = await route.beforeModel();\n          (0, _chai.expect)(result).to.equal('upstreamReturnValue');\n        });\n      });\n    });\n  });\n});","define(\"dummy/tests/unit/register-version-test\", [\"mocha\", \"chai\", \"dummy/config/environment\"], function (_mocha, _chai, _environment) {\n  \"use strict\";\n\n  const {\n    libraries\n  } = Ember;\n  const expectedVersion = _environment.default.esaVersion;\n  (0, _mocha.describe)('register-version', () => {\n    (0, _mocha.it)('registers \"Ember Simple Auth\" as a library', function () {\n      (0, _chai.expect)(libraries._getLibraryByName('Ember Simple Auth')).to.deep.equal({\n        name: 'Ember Simple Auth',\n        version: expectedVersion\n      });\n    });\n  });\n});","define(\"dummy/tests/unit/routes/application-test\", [\"chai\", \"mocha\", \"ember-mocha\"], function (_chai, _mocha, _emberMocha) {\n  \"use strict\";\n\n  (0, _mocha.describe)('ApplicationRoute', function () {\n    (0, _emberMocha.setupTest)();\n    (0, _mocha.it)('is still testable when using the ApplicationRouteMixin', function () {\n      const route = this.owner.lookup('route:application');\n      (0, _chai.expect)(route).to.be.ok;\n    });\n  });\n});","define(\"dummy/tests/unit/routes/login-test\", [\"chai\", \"mocha\", \"ember-mocha\"], function (_chai, _mocha, _emberMocha) {\n  \"use strict\";\n\n  (0, _mocha.describe)('LoginRoute', function () {\n    (0, _emberMocha.setupTest)();\n    (0, _mocha.it)('is still testable when using the UnauthenticatedRouteMixin', function () {\n      const route = this.owner.lookup('route:login');\n      (0, _chai.expect)(route).to.be.ok;\n    });\n  });\n});","define(\"dummy/tests/unit/routes/protected-test\", [\"chai\", \"mocha\", \"ember-mocha\"], function (_chai, _mocha, _emberMocha) {\n  \"use strict\";\n\n  (0, _mocha.describe)('ProtectedRoute', function () {\n    (0, _emberMocha.setupTest)();\n    (0, _mocha.it)('is still testable when using the AuthenticatedRouteMixin', function () {\n      const route = this.owner.lookup('route:protected');\n      (0, _chai.expect)(route).to.be.ok;\n    });\n  });\n});","define(\"dummy/tests/unit/services/session-test\", [\"mocha\", \"ember-mocha\", \"chai\", \"sinon\", \"ember-simple-auth/services/session\"], function (_mocha, _emberMocha, _chai, _sinon, _session) {\n  \"use strict\";\n\n  (0, _mocha.describe)('SessionService', () => {\n    (0, _emberMocha.setupTest)();\n    let sinon;\n    let sessionService;\n    let session;\n    (0, _mocha.beforeEach)(function () {\n      sinon = _sinon.default.createSandbox();\n      session = Ember.ObjectProxy.extend(Ember.Evented, {\n        init() {\n          this._super(...arguments);\n\n          this.content = {};\n        }\n\n      }).create();\n      this.owner.register('authorizer:custom', Ember.Object.extend({\n        authorize() {}\n\n      }));\n      sessionService = _session.default.create({\n        session\n      });\n      Ember.setOwner(sessionService, this.owner);\n    });\n    afterEach(function () {\n      sinon.restore();\n    });\n    (0, _mocha.it)('forwards the \"authenticationSucceeded\" event from the session', function (done) {\n      let triggered = false;\n      sessionService.one('authenticationSucceeded', () => triggered = true);\n      session.trigger('authenticationSucceeded');\n      Ember.run.next(() => {\n        (0, _chai.expect)(triggered).to.be.true;\n        done();\n      });\n    });\n    (0, _mocha.it)('forwards the \"invalidationSucceeded\" event from the session', function (done) {\n      let triggered = false;\n      sessionService.one('invalidationSucceeded', () => triggered = true);\n      session.trigger('invalidationSucceeded');\n      Ember.run.next(() => {\n        (0, _chai.expect)(triggered).to.be.true;\n        done();\n      });\n    });\n    (0, _mocha.describe)('isAuthenticated', function () {\n      (0, _mocha.it)('is read from the session', function () {\n        session.set('isAuthenticated', true);\n        (0, _chai.expect)(sessionService.get('isAuthenticated')).to.be.true;\n      });\n      (0, _mocha.it)('is read-only', function () {\n        (0, _chai.expect)(() => {\n          sessionService.set('isAuthenticated', false);\n        }).to.throw;\n      });\n    });\n    (0, _mocha.describe)('store', function () {\n      (0, _mocha.it)('is read from the session', function () {\n        session.set('store', 'some store');\n        (0, _chai.expect)(sessionService.get('store')).to.eq('some store');\n      });\n      (0, _mocha.it)('is read-only', function () {\n        (0, _chai.expect)(() => {\n          sessionService.set('store', 'some other store');\n        }).to.throw;\n      });\n    });\n    (0, _mocha.describe)('attemptedTransition', function () {\n      (0, _mocha.it)('is read from the session', function () {\n        session.set('attemptedTransition', 'some transition');\n        (0, _chai.expect)(sessionService.get('attemptedTransition')).to.eq('some transition');\n      });\n      (0, _mocha.it)('is written back to the session', function () {\n        sessionService.set('attemptedTransition', 'some other transition');\n        (0, _chai.expect)(session.get('attemptedTransition')).to.eq('some other transition');\n      });\n    });\n    (0, _mocha.describe)('data', function () {\n      (0, _mocha.it)(\"is read from the session's content\", function () {\n        session.set('some', 'data');\n        (0, _chai.expect)(sessionService.get('data')).to.eql({\n          some: 'data'\n        });\n      });\n      (0, _mocha.it)(\"is written back to the session's content\", function () {\n        sessionService.set('data.some', {\n          other: 'data'\n        });\n        (0, _chai.expect)(session.content).to.eql({\n          some: {\n            other: 'data'\n          }\n        });\n      });\n      (0, _mocha.it)('can be set with Ember.set', function () {\n        Ember.set(sessionService, 'data.emberSet', 'ember-set-data');\n        (0, _chai.expect)(session.content).to.eql({\n          emberSet: 'ember-set-data'\n        });\n      });\n      (0, _mocha.it)('is read-only', function () {\n        (0, _chai.expect)(() => {\n          sessionService.set('data', false);\n        }).to.throw;\n      });\n    });\n    (0, _mocha.describe)('authenticate', function () {\n      (0, _mocha.beforeEach)(function () {\n        session.reopen({\n          authenticate() {\n            return 'value';\n          }\n\n        });\n      });\n      (0, _mocha.it)('authenticates the session', function () {\n        sinon.spy(session, 'authenticate');\n        sessionService.authenticate({\n          some: 'argument'\n        });\n        (0, _chai.expect)(session.authenticate).to.have.been.calledWith({\n          some: 'argument'\n        });\n      });\n      (0, _mocha.it)(\"returns the session's authentication return value\", function () {\n        (0, _chai.expect)(sessionService.authenticate()).to.eq('value');\n      });\n    });\n    (0, _mocha.describe)('invalidate', function () {\n      (0, _mocha.beforeEach)(function () {\n        session.reopen({\n          invalidate() {\n            return 'value';\n          }\n\n        });\n      });\n      (0, _mocha.it)('invalidates the session', function () {\n        sinon.spy(session, 'invalidate');\n        sessionService.invalidate({\n          some: 'argument'\n        });\n        (0, _chai.expect)(session.invalidate).to.have.been.calledWith({\n          some: 'argument'\n        });\n      });\n      (0, _mocha.it)(\"returns the session's invalidation return value\", function () {\n        (0, _chai.expect)(sessionService.invalidate()).to.eq('value');\n      });\n    });\n  });\n});","define(\"dummy/tests/unit/session-stores/adaptive-test\", [\"mocha\", \"chai\", \"sinon\", \"ember-simple-auth/session-stores/adaptive\", \"ember-simple-auth/session-stores/local-storage\", \"dummy/tests/unit/session-stores/shared/store-behavior\", \"dummy/tests/unit/session-stores/shared/cookie-store-behavior\", \"dummy/tests/helpers/fake-cookie-service\", \"dummy/tests/helpers/create-adaptive-store\"], function (_mocha, _chai, _sinon, _adaptive, _localStorage, _storeBehavior, _cookieStoreBehavior, _fakeCookieService, _createAdaptiveStore) {\n  \"use strict\";\n\n  (0, _mocha.describe)('AdaptiveStore', () => {\n    let sinon;\n    let store;\n    (0, _mocha.beforeEach)(function () {\n      sinon = _sinon.default.createSandbox();\n    });\n    (0, _mocha.afterEach)(function () {\n      store.clear();\n      sinon.restore();\n    });\n    (0, _mocha.describe)('when localStorage is available', function () {\n      (0, _mocha.beforeEach)(function () {\n        store = _adaptive.default.extend({\n          _createStore(storeType, options) {\n            return _localStorage.default.create({\n              _isFastBoot: false\n            }, options);\n          }\n\n        }).create({\n          _isLocalStorageAvailable: true\n        });\n      });\n      (0, _storeBehavior.default)({\n        store() {\n          return store;\n        }\n\n      });\n    });\n    (0, _mocha.describe)('when localStorage is not available', function () {\n      let cookieService;\n      (0, _mocha.beforeEach)(function () {\n        cookieService = _fakeCookieService.default.create();\n        sinon.spy(cookieService, 'read');\n        sinon.spy(cookieService, 'write');\n        store = (0, _createAdaptiveStore.default)(cookieService, {\n          _isLocal: false,\n          _cookies: cookieService\n        });\n      });\n      (0, _storeBehavior.default)({\n        store() {\n          return store;\n        }\n\n      });\n      (0, _cookieStoreBehavior.default)({\n        createStore(cookieService, options = {}) {\n          options._isLocalStorageAvailable = false;\n          return (0, _createAdaptiveStore.default)(cookieService, options, {\n            _cookies: cookieService,\n            _fastboot: {\n              isFastBoot: false\n            }\n          });\n        },\n\n        renew(store, data) {\n          return store.get('_store')._renew(data);\n        },\n\n        sync(store) {\n          store.get('_store')._syncData();\n        },\n\n        spyRewriteCookieMethod(store) {\n          sinon.spy(store.get('_store'), 'rewriteCookie');\n          return store.get('_store').rewriteCookie;\n        }\n\n      });\n      (0, _mocha.it)('persists to cookie when cookie attributes change', function () {\n        let now = new Date();\n        Ember.run(() => {\n          store.persist({\n            key: 'value'\n          });\n          store.setProperties({\n            cookieName: 'test:session',\n            cookieExpirationTime: 60\n          });\n        });\n        (0, _chai.expect)(cookieService.write).to.have.been.calledWith('test:session-expiration_time', 60, sinon.match(function ({\n          domain,\n          expires,\n          path,\n          secure\n        }) {\n          return domain === null && path === '/' && secure === false && expires >= new Date(now.getTime() + 60 * 1000);\n        }));\n      });\n    });\n  });\n});","define(\"dummy/tests/unit/session-stores/cookie-test\", [\"mocha\", \"sinon\", \"dummy/tests/unit/session-stores/shared/store-behavior\", \"dummy/tests/unit/session-stores/shared/cookie-store-behavior\", \"dummy/tests/helpers/fake-cookie-service\", \"dummy/tests/helpers/create-cookie-store\"], function (_mocha, _sinon, _storeBehavior, _cookieStoreBehavior, _fakeCookieService, _createCookieStore) {\n  \"use strict\";\n\n  (0, _mocha.describe)('CookieStore', () => {\n    let sinon;\n    let store;\n    (0, _mocha.beforeEach)(function () {\n      sinon = _sinon.default.createSandbox();\n      store = (0, _createCookieStore.default)(_fakeCookieService.default.create());\n    });\n    afterEach(function () {\n      sinon.restore();\n    });\n    (0, _storeBehavior.default)({\n      store() {\n        return store;\n      },\n\n      syncExternalChanges() {\n        store._syncData();\n      }\n\n    });\n    (0, _cookieStoreBehavior.default)({\n      createStore(cookiesService, options = {}) {\n        return (0, _createCookieStore.default)(cookiesService, options);\n      },\n\n      renew(store, data) {\n        return store._renew(data);\n      },\n\n      sync(store) {\n        store._syncData();\n      },\n\n      spyRewriteCookieMethod(store) {\n        sinon.spy(store, 'rewriteCookie');\n        return store.rewriteCookie;\n      }\n\n    });\n  });\n});","define(\"dummy/tests/unit/session-stores/ephemeral-test\", [\"mocha\", \"ember-simple-auth/session-stores/ephemeral\", \"dummy/tests/unit/session-stores/shared/store-behavior\"], function (_mocha, _ephemeral, _storeBehavior) {\n  \"use strict\";\n\n  (0, _mocha.describe)('EphemeralStore', function () {\n    (0, _storeBehavior.default)({\n      store() {\n        return _ephemeral.default.create();\n      }\n\n    });\n  });\n});","define(\"dummy/tests/unit/session-stores/local-storage-test\", [\"mocha\", \"ember-simple-auth/session-stores/local-storage\", \"dummy/tests/unit/session-stores/shared/store-behavior\", \"dummy/tests/unit/session-stores/shared/storage-event-handler-behavior\"], function (_mocha, _localStorage, _storeBehavior, _storageEventHandlerBehavior) {\n  \"use strict\";\n\n  (0, _mocha.describe)('LocalStorageStore', function () {\n    (0, _storeBehavior.default)({\n      store() {\n        return _localStorage.default.create({\n          _isFastBoot: false\n        });\n      }\n\n    });\n    (0, _storageEventHandlerBehavior.default)({\n      store() {\n        return _localStorage.default.create({\n          _isFastBoot: false\n        });\n      }\n\n    });\n  });\n});","define(\"dummy/tests/unit/session-stores/session-storage-test\", [\"mocha\", \"ember-simple-auth/session-stores/session-storage\", \"dummy/tests/unit/session-stores/shared/store-behavior\", \"dummy/tests/unit/session-stores/shared/storage-event-handler-behavior\"], function (_mocha, _sessionStorage, _storeBehavior, _storageEventHandlerBehavior) {\n  \"use strict\";\n\n  (0, _mocha.describe)('SessionStorageStore', function () {\n    (0, _storeBehavior.default)({\n      store() {\n        return _sessionStorage.default.create({\n          _isFastBoot: false\n        });\n      }\n\n    });\n    (0, _storageEventHandlerBehavior.default)({\n      store() {\n        return _sessionStorage.default.create({\n          _isFastBoot: false\n        });\n      }\n\n    });\n  });\n});","define(\"dummy/tests/unit/session-stores/shared/cookie-store-behavior\", [\"exports\", \"mocha\", \"chai\", \"sinon\", \"dummy/tests/helpers/fake-cookie-service\"], function (_exports, _mocha, _chai, _sinon, _fakeCookieService) {\n  \"use strict\";\n\n  Object.defineProperty(_exports, \"__esModule\", {\n    value: true\n  });\n  _exports.default = _default;\n  let warnings;\n  Ember.Debug.registerWarnHandler((message, options, next) => {\n    // in case a deprecation is issued before a test is started\n    if (!warnings) {\n      warnings = [];\n    }\n\n    warnings.push(message);\n    next(message, options);\n  });\n\n  function _default(options) {\n    let sinon;\n    let store;\n    let createStore;\n    let renew;\n    let sync;\n    let cookieService;\n    let spyRewriteCookieMethod; // eslint-disable-next-line mocha/no-top-level-hooks\n\n    (0, _mocha.beforeEach)(function () {\n      sinon = _sinon.default.createSandbox();\n      createStore = options.createStore;\n      renew = options.renew;\n      sync = options.sync;\n      cookieService = _fakeCookieService.default.create();\n      sinon.spy(cookieService, 'read');\n      sinon.spy(cookieService, 'write');\n      store = createStore(cookieService);\n      spyRewriteCookieMethod = options.spyRewriteCookieMethod;\n    }); // eslint-disable-next-line mocha/no-top-level-hooks\n\n    (0, _mocha.afterEach)(function () {\n      sinon.restore();\n      store.clear();\n    });\n    (0, _mocha.describe)('#persist', function () {\n      (0, _mocha.beforeEach)(function () {\n        warnings = [];\n      });\n      (0, _mocha.it)('respects the configured cookieName', function () {\n        let store;\n        Ember.run(() => {\n          store = createStore(cookieService, {\n            cookieName: 'test-session'\n          });\n        });\n        store.persist({\n          key: 'value'\n        });\n        (0, _chai.expect)(cookieService.write).to.have.been.calledWith('test-session', JSON.stringify({\n          key: 'value'\n        }), {\n          domain: null,\n          expires: null,\n          path: '/',\n          sameSite: null,\n          secure: false\n        });\n      });\n      (0, _mocha.it)('respects the configured cookieDomain', function () {\n        let store;\n        Ember.run(() => {\n          store = createStore(cookieService, {\n            cookieName: 'session-cookie-domain',\n            cookieDomain: 'example.com'\n          });\n          store.persist({\n            key: 'value'\n          });\n        });\n        (0, _chai.expect)(cookieService.write).to.have.been.calledWith('session-cookie-domain', JSON.stringify({\n          key: 'value'\n        }), {\n          domain: 'example.com',\n          expires: null,\n          path: '/',\n          sameSite: null,\n          secure: false\n        });\n      });\n      (0, _mocha.it)('respects the configured cookiePath', function () {\n        let store;\n        Ember.run(() => {\n          store = createStore(cookieService, {\n            cookieName: 'session-cookie-domain',\n            cookieDomain: 'example.com',\n            cookiePath: '/hello-world'\n          });\n          store.persist({\n            key: 'value'\n          });\n        });\n        (0, _chai.expect)(cookieService.write).to.have.been.calledWith('session-cookie-domain', JSON.stringify({\n          key: 'value'\n        }), {\n          domain: 'example.com',\n          expires: null,\n          path: '/hello-world',\n          sameSite: null,\n          secure: false\n        });\n      });\n      (0, _mocha.it)('respects the configured sameSite', function () {\n        let store;\n        Ember.run(() => {\n          store = createStore(cookieService, {\n            cookieName: 'session-cookie-domain',\n            cookieDomain: 'example.com',\n            sameSite: 'Strict'\n          });\n          store.persist({\n            key: 'value'\n          });\n        });\n        (0, _chai.expect)(cookieService.write).to.have.been.calledWith('session-cookie-domain', JSON.stringify({\n          key: 'value'\n        }), {\n          domain: 'example.com',\n          expires: null,\n          path: '/',\n          sameSite: 'Strict',\n          secure: false\n        });\n      });\n      (0, _mocha.it)('sends a warning when `cookieExpirationTime` is less than 90 seconds', function (done) {\n        Ember.run(() => {\n          createStore(cookieService, {\n            cookieName: 'session-cookie-domain',\n            cookieDomain: 'example.com',\n            cookieExpirationTime: 60\n          });\n          (0, _chai.expect)(warnings).to.have.length(1);\n          (0, _chai.expect)(warnings[0]).to.equal('The recommended minimum value for `cookieExpirationTime` is 90 seconds. If your value is less than that, the cookie may expire before its expiration time is extended (expiration time is extended every 60 seconds).');\n          done();\n        });\n      });\n    });\n    (0, _mocha.describe)('#renew', function () {\n      let now = new Date();\n      (0, _mocha.beforeEach)(async function () {\n        store = createStore(cookieService, {\n          cookieName: 'test-session',\n          cookieExpirationTime: 60\n        });\n        store.persist({\n          key: 'value'\n        });\n        await renew(store);\n      });\n      (0, _mocha.it)('stores the expiration time in a cookie named \"test-session-expiration_time\"', function () {\n        (0, _chai.expect)(cookieService.write).to.have.been.calledWith('test-session-expiration_time', 60, sinon.match(function ({\n          domain,\n          expires,\n          path,\n          secure\n        }) {\n          return domain === null && path === '/' && secure === false && expires >= new Date(now.getTime() + 60 * 1000);\n        }));\n      });\n    });\n    (0, _mocha.describe)('the \"sessionDataUpdated\" event', function () {\n      let triggered;\n      (0, _mocha.beforeEach)(function () {\n        triggered = false;\n        store.persist({\n          key: 'value'\n        });\n        store.one('sessionDataUpdated', () => {\n          triggered = true;\n        });\n      });\n      (0, _mocha.it)('is not triggered when the cookie has not actually changed', function (done) {\n        document.cookie = 'ember_simple_auth-session=%7B%22key%22%3A%22value%22%7D;path=/;';\n        sync(store);\n        Ember.run.next(() => {\n          (0, _chai.expect)(triggered).to.be.false;\n          done();\n        });\n      });\n      (0, _mocha.it)('is triggered when the cookie changed', function (done) {\n        const cookiesService = store.get('_cookies') || store.get('_store._cookies');\n        cookiesService._content['ember_simple_auth-session'] = '%7B%22key%22%3A%22other%20value%22%7D';\n        sync(store);\n        Ember.run.next(() => {\n          Ember.run.next(() => {\n            (0, _chai.expect)(triggered).to.be.true;\n            done();\n          });\n        });\n      });\n      (0, _mocha.it)('is not triggered when the cookie expiration was renewed', function (done) {\n        renew(store, {\n          key: 'value'\n        });\n        sync(store);\n        Ember.run.next(() => {\n          (0, _chai.expect)(triggered).to.be.false;\n          done();\n        });\n      });\n    });\n    (0, _mocha.describe)('rewrite behavior', function () {\n      let store;\n      let cookieSpy;\n      let cookieService;\n      let now = new Date();\n      (0, _mocha.beforeEach)(function () {\n        cookieService = _fakeCookieService.default.create();\n        store = createStore(cookieService, {\n          cookieName: 'session-foo',\n          cookieExpirationTime: 1000\n        });\n        cookieService = store.get('_cookies') || store.get('_store._cookies');\n        cookieSpy = spyRewriteCookieMethod(store);\n        sinon.spy(cookieService, 'write');\n        sinon.spy(cookieService, 'clear');\n      });\n      (0, _mocha.afterEach)(function () {\n        cookieService.write.restore();\n        cookieService.clear.restore();\n        cookieSpy.restore();\n      });\n      (0, _mocha.it)('deletes the old cookie and writes a new one when name property changes', function () {\n        Ember.run(() => {\n          store.persist({\n            key: 'value'\n          });\n          store.set('cookieName', 'session-bar');\n        });\n        (0, _chai.expect)(cookieService.clear).to.have.been.calledWith('session-foo');\n        (0, _chai.expect)(cookieService.clear).to.have.been.calledWith('session-foo-expiration_time');\n        (0, _chai.expect)(cookieService.write).to.have.been.calledWith('session-bar', JSON.stringify({\n          key: 'value'\n        }), sinon.match(function ({\n          domain,\n          expires,\n          path,\n          secure\n        }) {\n          return domain === null && path === '/' && secure === false && expires >= new Date(now.getTime() + 1000 * 1000);\n        }));\n        (0, _chai.expect)(cookieService.write).to.have.been.calledWith('session-bar-expiration_time', 1000, sinon.match(function ({\n          domain,\n          expires,\n          path,\n          secure\n        }) {\n          return domain === null && path === '/' && secure === false && expires >= new Date(now.getTime() + 1000 * 1000);\n        }));\n      });\n      (0, _mocha.it)('deletes the old cookie and writes a new one when domain property changes', function () {\n        let defaultName = 'ember_simple_auth-session';\n        Ember.run(() => {\n          store.persist({\n            key: 'value'\n          });\n          store.set('cookieDomain', 'example.com');\n        });\n        (0, _chai.expect)(cookieService.clear).to.have.been.calledWith(defaultName);\n        (0, _chai.expect)(cookieService.clear).to.have.been.calledWith(`${defaultName}-expiration_time`);\n        (0, _chai.expect)(cookieService.write).to.have.been.calledWith('session-foo', JSON.stringify({\n          key: 'value'\n        }), sinon.match(function ({\n          domain,\n          expires,\n          path,\n          secure\n        }) {\n          return domain === 'example.com' && path === '/' && secure === false && expires >= new Date(now.getTime() + 1000 * 1000);\n        }));\n      });\n      (0, _mocha.it)('deletes the old cookie and writes a new one when expiration property changes', function () {\n        let defaultName = 'ember_simple_auth-session';\n        let expirationTime = 180;\n        Ember.run(() => {\n          store.persist({\n            key: 'value'\n          });\n          store.set('cookieExpirationTime', expirationTime);\n        });\n        (0, _chai.expect)(cookieService.clear).to.have.been.calledWith(defaultName);\n        (0, _chai.expect)(cookieService.clear).to.have.been.calledWith(`${defaultName}-expiration_time`);\n        (0, _chai.expect)(cookieService.write).to.have.been.calledWith('session-foo', JSON.stringify({\n          key: 'value'\n        }), sinon.match(function ({\n          domain,\n          expires,\n          path,\n          secure\n        }) {\n          return domain === null && path === '/' && secure === false && expires >= new Date(now.getTime() + (expirationTime - 10) * 1000);\n        }));\n      });\n      (0, _mocha.it)('clears cached expiration times when setting expiration to null', function () {\n        Ember.run(() => {\n          store.set('cookieExpirationTime', null);\n        });\n        (0, _chai.expect)(cookieService.clear).to.have.been.calledWith(`session-foo-expiration_time`);\n      });\n      (0, _mocha.it)('only rewrites the cookie once per run loop when multiple properties are changed', function (done) {\n        Ember.run(() => {\n          store.set('cookieName', 'session-bar');\n          store.set('cookieExpirationTime', 10000);\n        });\n        Ember.run.next(() => {\n          (0, _chai.expect)(cookieSpy).to.have.been.calledOnce;\n          done();\n        });\n      });\n    });\n    (0, _mocha.describe)('#init', function () {\n      let cookieName = 'ember_simple_auth-session-expiration_time';\n      let expirationTime = 60 * 60 * 24;\n      (0, _mocha.beforeEach)(function () {\n        cookieService.write(cookieName, expirationTime);\n        store = createStore(cookieService);\n      });\n      (0, _mocha.afterEach)(function () {\n        cookieService.clear(cookieName);\n      });\n      (0, _mocha.it)('restores expiration time from cookie', function () {\n        (0, _chai.expect)(store.get('cookieExpirationTime')).to.equal(expirationTime);\n      });\n    });\n  }\n});","define(\"dummy/tests/unit/session-stores/shared/storage-event-handler-behavior\", [\"exports\", \"mocha\", \"chai\", \"sinon\"], function (_exports, _mocha, _chai, _sinon) {\n  \"use strict\";\n\n  Object.defineProperty(_exports, \"__esModule\", {\n    value: true\n  });\n  _exports.default = _default;\n\n  function _default(options) {\n    let sinon;\n    let store; // eslint-disable-next-line mocha/no-top-level-hooks\n\n    (0, _mocha.beforeEach)(function () {\n      sinon = _sinon.default.createSandbox();\n      store = options.store();\n    }); // eslint-disable-next-line mocha/no-top-level-hooks\n\n    afterEach(function () {\n      sinon.restore();\n    });\n    (0, _mocha.describe)('storage events', function () {\n      (0, _mocha.beforeEach)(function () {\n        sinon.spy(window, 'addEventListener');\n        sinon.spy(window, 'removeEventListener');\n      });\n      afterEach(function () {\n        window.addEventListener.restore();\n        window.removeEventListener.restore();\n      });\n      (0, _mocha.it)('binds to \"storage\" events on the window when created', function () {\n        store = options.store();\n        (0, _chai.expect)(window.addEventListener).to.have.been.calledOnce;\n      });\n      (0, _mocha.it)('triggers the \"sessionDataUpdated\" event when the data in the browser storage has changed', function () {\n        let triggered = false;\n        store.on('sessionDataUpdated', () => {\n          triggered = true;\n        });\n        window.dispatchEvent(new StorageEvent('storage', {\n          key: store.get('key')\n        }));\n        (0, _chai.expect)(triggered).to.be.true;\n      });\n      (0, _mocha.it)('does not trigger the \"sessionDataUpdated\" event when the data in the browser storage has not changed', function () {\n        let triggered = false;\n        store.on('sessionDataUpdated', () => {\n          triggered = true;\n        });\n        store.persist({\n          key: 'value'\n        }); // this data will be read again when the event is handled so that no change will be detected\n\n        window.dispatchEvent(new StorageEvent('storage', {\n          key: store.get('key')\n        }));\n        (0, _chai.expect)(triggered).to.be.false;\n      });\n      (0, _mocha.it)('does not trigger the \"sessionDataUpdated\" event when the data in the browser storage has changed for a different key', function () {\n        let triggered = false;\n        store.on('sessionDataUpdated', () => {\n          triggered = true;\n        });\n        window.dispatchEvent(new StorageEvent('storage', {\n          key: 'another key'\n        }));\n        (0, _chai.expect)(triggered).to.be.false;\n      });\n      (0, _mocha.it)('unbinds from \"storage\" events on the window when destroyed', function () {\n        Ember.run(() => store.destroy());\n        (0, _chai.expect)(window.removeEventListener).to.have.been.calledOnce;\n      });\n    });\n  }\n});","define(\"dummy/tests/unit/session-stores/shared/store-behavior\", [\"exports\", \"mocha\", \"chai\"], function (_exports, _mocha, _chai) {\n  \"use strict\";\n\n  Object.defineProperty(_exports, \"__esModule\", {\n    value: true\n  });\n  _exports.default = _default;\n\n  function _default(options) {\n    let syncExternalChanges = options.syncExternalChanges || function () {};\n\n    let store; // eslint-disable-next-line mocha/no-top-level-hooks\n\n    (0, _mocha.beforeEach)(function () {\n      store = options.store();\n    }); // eslint-disable-next-line mocha/no-top-level-hooks\n\n    afterEach(function () {\n      store.clear();\n    });\n    (0, _mocha.describe)('#persist', function () {\n      (0, _mocha.it)('persists an object', async function () {\n        await store.persist({\n          key: 'value'\n        });\n        let restoredContent = await store.restore();\n        (0, _chai.expect)(restoredContent).to.eql({\n          key: 'value'\n        });\n      });\n      (0, _mocha.it)('overrides existing data', async function () {\n        await store.persist({\n          key1: 'value1'\n        });\n        await store.persist({\n          key2: 'value2'\n        });\n        let restoredContent = await store.restore();\n        (0, _chai.expect)(restoredContent).to.eql({\n          key2: 'value2'\n        });\n      });\n      (0, _mocha.it)('does not trigger the \"sessionDataUpdated\" event', function (done) {\n        let triggered = false;\n        store.one('sessionDataUpdated', () => triggered = true);\n        store.persist({\n          key: 'other value'\n        });\n        syncExternalChanges();\n        Ember.run.next(() => {\n          (0, _chai.expect)(triggered).to.be.false;\n          done();\n        });\n      });\n    });\n    (0, _mocha.describe)('#restore', function () {\n      (0, _mocha.describe)('when the store is empty', function () {\n        (0, _mocha.it)('returns an empty object', async function () {\n          await store.clear();\n          let restoredContent = await store.restore();\n          (0, _chai.expect)(restoredContent).to.eql({});\n        });\n      });\n      (0, _mocha.describe)('when the store has data', function () {\n        (0, _mocha.beforeEach)(function () {\n          return store.persist({\n            key1: 'value1',\n            key2: 'value2'\n          });\n        });\n        (0, _mocha.it)('returns all data in the store', async function () {\n          let restoredContent = await store.restore();\n          (0, _chai.expect)(restoredContent).to.eql({\n            key1: 'value1',\n            key2: 'value2'\n          });\n        });\n        (0, _mocha.it)('returns a copy of the stored data', async function () {\n          let data = await store.restore();\n          data.key1 = 'another value!';\n          let restoredContent = await store.restore();\n          (0, _chai.expect)(restoredContent).to.eql({\n            key1: 'value1',\n            key2: 'value2'\n          });\n        });\n      });\n    });\n    (0, _mocha.describe)('#clear', function () {\n      (0, _mocha.it)('empties the store', async function () {\n        await store.persist({\n          key1: 'value1',\n          key2: 'value2'\n        });\n        await store.clear();\n        let restoredContent = await store.restore();\n        (0, _chai.expect)(restoredContent).to.eql({});\n      });\n    });\n  }\n});","define(\"dummy/tests/unit/utils/location-test\", [\"chai\", \"mocha\", \"ember-simple-auth/utils/location\", \"sinon\"], function (_chai, _mocha, LocationUtil, _sinon) {\n  \"use strict\";\n\n  // eslint-disable-next-line\n  const foo = {\n    get hash() {\n      return LocationUtil.default().hash;\n    }\n\n  };\n  (0, _mocha.describe)('Unit | Utility | location', function () {\n    let sinon;\n    (0, _mocha.beforeEach)(function () {\n      sinon = _sinon.default.createSandbox();\n    });\n    (0, _mocha.afterEach)(function () {\n      sinon.restore();\n    });\n    (0, _mocha.it)('works', function () {\n      (0, _chai.expect)(LocationUtil.default()).to.be.ok;\n      (0, _chai.expect)(LocationUtil.default().hash).to.be.a('string');\n    });\n  });\n});","define(\"dummy/tests/unit/utils/objects-are-equal-test\", [\"mocha\", \"chai\", \"ember-simple-auth/utils/objects-are-equal\"], function (_mocha, _chai, _objectsAreEqual) {\n  \"use strict\";\n\n  (0, _mocha.describe)('objectsAreEqual', () => {\n    (0, _mocha.it)('is true for equal objects', function () {\n      (0, _chai.expect)((0, _objectsAreEqual.default)({\n        a: 'b',\n        c: 'd'\n      }, {\n        a: 'b',\n        c: 'd'\n      })).to.be.true;\n    });\n    (0, _mocha.it)('is true for equal objects regardless of property order', function () {\n      (0, _chai.expect)((0, _objectsAreEqual.default)({\n        a: 'b',\n        c: 'd'\n      }, {\n        c: 'd',\n        a: 'b'\n      })).to.be.true;\n    });\n    (0, _mocha.it)('is true for equal nested objects regardless of property order', function () {\n      (0, _chai.expect)((0, _objectsAreEqual.default)({\n        a: 'b',\n        c: 'd',\n        e: {\n          f: 'g'\n        }\n      }, {\n        e: {\n          f: 'g'\n        },\n        a: 'b',\n        c: 'd'\n      })).to.be.true;\n    });\n    (0, _mocha.it)('is true for equal objects that include arrays', function () {\n      (0, _chai.expect)((0, _objectsAreEqual.default)({\n        a: ['b', 'c']\n      }, {\n        a: ['b', 'c']\n      })).to.be.true;\n    });\n    (0, _mocha.it)('is false for equal objects that include differently ordered arrays', function () {\n      (0, _chai.expect)((0, _objectsAreEqual.default)({\n        a: ['b', 'c']\n      }, {\n        a: ['c', 'b']\n      })).to.be.false;\n    });\n    (0, _mocha.it)('is false for unequal objects', function () {\n      (0, _chai.expect)((0, _objectsAreEqual.default)({\n        a: 'b'\n      }, {\n        c: 'd'\n      })).to.be.false;\n    });\n  });\n});","define('dummy/config/environment', [], function() {\n  if (typeof FastBoot !== 'undefined') {\nreturn FastBoot.config('dummy');\n} else {\nvar prefix = 'dummy';try {\n  var metaName = prefix + '/config/environment';\n  var rawConfig = document.querySelector('meta[name=\"' + metaName + '\"]').getAttribute('content');\n  var config = JSON.parse(decodeURIComponent(rawConfig));\n\n  var exports = { 'default': config };\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n  return exports;\n}\ncatch(err) {\n  throw new Error('Could not read config from meta tag with name \"' + metaName + '\".');\n}\n\n}\n});\n","require('dummy/tests/test-helper');\nEmberENV.TESTS_FILE_LOADED = true;\n"],"names":[],"mappings":"AAAA;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrBA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1bA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACx2BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5UA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;","file":"tests.js"}